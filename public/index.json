[{"body":"","link":"https://huangbaihua.gitee.io/","section":"","tags":null,"title":""},{"body":"","link":"https://huangbaihua.gitee.io/categories/","section":"categories","tags":null,"title":"Categories"},{"body":"","link":"https://huangbaihua.gitee.io/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"","link":"https://huangbaihua.gitee.io/post/","section":"post","tags":["index"],"title":"所有文章索引"},{"body":"英语语法之所以难学，一般是没有在脑海里建立清晰的语法体系。如何在脑海里构建自己的语法体系呢？该文章以英语语法中最重要的动词为主线，概括了一套英语语法体系。\n以动词概括的英语语法体系 1 学习英语语法的目的 造好句子是学习英语语法的终极目的。\n2 最基本的句子成分 最基本的句子就是当句子拆到不能再拆时的句子。\n最基本的名子成分: 什么 + 怎么样。\n主语(subject)（什么），主语一般是人或物。\n谓语动词(predicate) (怎么样)。\n几乎所有的英语句子都是主语 + 谓语。\n3 动词 动词分为谓语动词和非谓语动词。谓语动词分为5种，分别决定了简单句（不能再拆）的 5种 基本句型。\n同时也囊括以下句子成分： 主语，谓语动词，宾语，宾语补语，主语补语（表语）。除此之外，句子成分还有，定语，状语，同位语。\n简单句可以组合成并列关系的“复合句”（并列复合名) 以及从属关系的“复杂 名”(主从复杂句)，后者包括 主句和从句 ，从句可以充当除谓语动词外的句子成分。\n句子成分可以由不同的词类充当，分别是： 名词，介词，冠词，代词，形容词，副词，连词，数词，叹词。\n3.1 谓语动词 3.1.1 种动词类型 3.1.1.1 不及物动词 可以独立完成的动作。主语 + 不及物动词。\n如：She sleeps.\n3.1.1.2 单及物动词 有一个动作的承受者。 主语 + 单及物动词 + 宾语。\n如：I like you.\n3.1.1.3 双及物动词 有2个动作承受者。主语 + 双及物动词 + 间接宾语 + 直接宾语。\n如：She teaches me English.\n3.1.1.4 复杂及物动词 只有一个动作承受者（但需补充)。主语 + 复杂及物动词 + 宾语 +（宾语）补语\n如： I consider you smart.\n3.1.1.5 系动词 非“动作\u0026quot;这类动词把后者信息赋予前者。主语 + (连)系动词 + (主语)补语/表语。\n如： I am tall. She is tall. She looks tall.\n3.1.2 简单句的5种基本类型 5种谓语动词分别决定了简单句（不能再拆）的5种基本句型\n无需承受者(宾语): 主语 + 不及物动词 一个宾语，无补充信息： 主语 + 单及物动词 + 宾语 (这也是最常见的 主 + 谓 + 宾 结构) 两个宾语，主语 + 双及物动词 + 间接宾语 + 直接宾语 一个宾语+补充信息： 主语 + 复杂及物动词 + 宾语 + （宾语）补语 赋予状态或信息: 主语 + 系动词 + (主语) 补语 / 表语 3.1.3 句子成分 囊括以下8种句子成分\n主语 （Subject) 谓语动词 (Predicate Verb 宾语 (Object) 宾语补语 (Object Complement) 主语补语 (Subject Complement) 定语（主要修饰主语或宾语）(Attributive) 状语 （主要修饰谓语动词）(Adverbial) 同位语 （主要用来再把主语或宾语说一遍）(Appositive) 3.1.4 词性(词类) 句子成分可以由不同的词类充当\n名词 Nouns 动词 Verbs 冠词 Articles 代词 Pronouns 形容词 Adjectives 数词 Numberals 副词 Adverbs 介词 Prepositions 叹词 Interjections 连词 Conjunctions 3.1.5 复杂句/并列句 简单句可以组合成并列关系的”复合名“以及从属关系的”复杂句“\n3.1.5.1 主从复杂句 3.1.5.1.1 主句(Main Clause) 3.1.5.1.2 从句(Subordinate Clause) 从句简单来说就是把简单句修改一下来充当另一个句子的句子成分\n简单句 作主语 叫 主语从句 简单句 作宾语 叫 宾语从句 简单句 作表语 叫 表语从句 简单句 作同位语 叫 同位语从句 简单句 作定语 叫 定语从句 简单句 作状语 叫 状语从句 3.1.5.2 并列复合句 3.1.6 谓语动词的“三大本领” 动作时间、动作状态、动作语气，其中 时间 + 状态 = 时态\n3.1.6.1 动作时间 现在 过去 将来 过去将来 3.1.6.2 动作状态 一般 完成 进行 完成进行 3.1.6.3 动作语气(动作假设，情感...) 谓语动词可以表达动作的时间，状态，语气等。但是需要用到助动词（包含情态动词）。助动词还能帮助否定动词，表达动词的被动，可能性，义务性...\n虚拟语气 陈述语气 祈使语气 例子： eat(吃)\n（协助）表示”吃过了(完成)\u0026quot; -\u0026gt; have -\u0026gt; have eaten （协助）表示”正在吃(进行)\u0026quot; -\u0026gt; be -\u0026gt; is eating （协助）表示”被吃\u0026quot; -\u0026gt; be-\u0026gt; is eaten （协助）表示”有能力吃\u0026quot; -\u0026gt; can-\u0026gt; can eat （协助）表示”有可能吃\u0026quot; -\u0026gt; might -\u0026gt; might eat （协助）表示”有义务吃\u0026quot; -\u0026gt; must -\u0026gt; must eat （协助）表示”不吃(否定)\u0026quot; -\u0026gt; do-\u0026gt; do not eat 3.2 非谓语动词 非谓语动词可以视作“改动后的”谓语动词，可以充当除谓语动词外的所有句子成分，取代几乎所有从句，简化句子。\n动词不定式 现在分词 动名词 过去分词 参考资料 一个视频说清整个英语语法体系(重塑你的语法认知框架)\n(全文完)\n","link":"https://huangbaihua.gitee.io/post/english/grammer-verb-outline/","section":"post","tags":["英语","英语语法"],"title":"以动词概括的英语语法体系"},{"body":"","link":"https://huangbaihua.gitee.io/tags/%E8%8B%B1%E8%AF%AD/","section":"tags","tags":null,"title":"英语"},{"body":"","link":"https://huangbaihua.gitee.io/categories/%E8%8B%B1%E8%AF%AD/","section":"categories","tags":null,"title":"英语"},{"body":"","link":"https://huangbaihua.gitee.io/tags/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/","section":"tags","tags":null,"title":"英语语法"},{"body":"","link":"https://huangbaihua.gitee.io/tags/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/","section":"tags","tags":null,"title":"IDEA插件开发"},{"body":"","link":"https://huangbaihua.gitee.io/categories/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/","section":"categories","tags":null,"title":"IDEA插件开发"},{"body":"Intellij IDEA 是业界公认最智能，最强大的 Java IDE。个人认为 Intellij 平台底层的抽象能力是非常强的。 PSI 就是其中之一。\nPSI 是程序结构接口 (Program Structure Interface) 的简称，在 Intellij 平台中负责解析文件、创建语法和语义代码模型。 它是平台的核心抽象层，支持平台的许多功能。\n文章目录 1. PSI 文件 1.1 如何获取 PSI 文件？ 1.2 可以用 PSI 文件做什么？ 1.3 PSI 文件来自哪里？ 1.4 PSI 文件能保存多久？ 1.5 如何创建PSI文件？ 1.6 当 PSI 文件改变时，如何得到通知？ 1.7 如何扩展 PSI ? 1.8 使用 PSI 有什么规则 ? 2. 文件视图提供者(File View Providers) 2.1 如何获得 FileViewProvider？ 2.2 可以用 FileViewProvider 做什么？ 2.3 如何扩展 FileViewProvider? 3 PSI 元素 3.1 怎么获取 PSI 元素 3.2 可以用 PSI 元素做什么？ 4. PSI 导航 4.1 自上而下导航 4.2 自下而上导航 5. PSI 引用 5.1 提供的引用 5.2 具有可选或多个解析结果的引用 5.3 查找引用 5.4 实现引用 6. 修改 PSI 6.1 创建 PSI 6.2 保持树结构的一致性 6.3 空格和包导入 6.4 结合 PSI 和文件的修改 7 PSI Cookbook 7.1 通用 7.2 Java 译自: PSI (intellij)\n1. PSI 文件 PSI 文件是一个结构的根，在特定的编程语言中将文件内容表示为一种具有层次结构的元素集合。\nPsiFile 类是所有 PSI 文件的共同基类，而特定语言的文件通常由其子类表示。例如，PsiJavaFile 类代表一个Java文件，而 XmlFile 类代表一个 XML 文件。\n与 VirtualFile 和 Document 不同，VirtualFile 和 Document 有其应用范围（即使打开了多个项目，每个文件都由同一个 VirtualFile 实例表示）， PSI 有其项目范围：如果文件属于同时打开的多个项目，同一个文件由多个 PsiFile 实例表示。\n1.1 如何获取 PSI 文件？ 从一个 Action： e.getData(CommonDataKeys.PSI_FILE). 从一个 VirtualFile: PsiManager.getInstance(project).findFile() 从一个 Document: PsiDocumentManager.getInstance(project).getPsiFile() 从一个文件中的元素: PsiElement.getContainingFile() 在项目任意地方获取具有特定名称的文件，使用 FilenameIndex.getFilesByName(project, name, scope) 1.2 可以用 PSI 文件做什么？ 大多数有趣的修改操作是在单个 PSI 元素的层面上进行的，而不是整个文件。\n要遍历一个文件中的元素，可以使用\n1 psiFile.accept(new PsiRecursiveElementWalkingVisitor() { 2 // visitor implementation ... 3 }); 1.3 PSI 文件来自哪里？ 因为 PSI 是依赖于语言的，因此 PSI 文件使用 Language 实例创建:\n1LanguageParserDefinitions.INSTANCE 2 .forLanguage(MyLanguage.INSTANCE) 3 .createFile(fileViewProvider); 与文件一样，PSI 文件是在访问特定文件的 PSI 时按需创建的。\n1.4 PSI 文件能保存多久？ 像文档一样，PSI 文件从相应的 VirtualFile 实例中被弱引用，如果不被任何实例引用，可以被垃圾收集器收集。\n1.5 如何创建PSI文件？ PsiFileFactory createFileFromText() 方法以指定的内容在内存中创建一个 PSI 文件。\n要将 PSI 文件保存到磁盘，请使用 PsiDirectory add() 方法。\n1.6 当 PSI 文件改变时，如何得到通知？ PsiManager.getInstance(project).addPsiTreeChangeListener() 允许你接收有关项目中的 PSI 树的所有变化的通知。 或者，在 com.intellij.psi.treeChangeListener 扩展点中注册 PsiTreeChangeListener。\n请参见 PsiTreeChangeEvent ,了解处理 PSI 事件时的常见问题.\n1.7 如何扩展 PSI ? PSI 可以通过自定义语言插件扩展支持更多的语言。关于开发自定义语言插件的更多细节， 请参见 自定义语言支持 参考指南。\n1.8 使用 PSI 有什么规则 ? 对 PSI 文件内容所做的任何改变都会反映在文档中，因此所有 处理文档的规则 （读/写操作、命令、只读状态处理）都是有效的。\n2. 文件视图提供者(File View Providers) 一个文件视图提供者（FileViewProvider）管理对单个文件中多个 PSI 树的访问。\n例如，一个 JSP 页面中的 Java 代码有一个单独的 PSI 树（PsiJavaFile）， XML 代码有一个单独的树（XmlFile），整个 JSP 有一个单独的树（JspFile）。\n每个 PSI 树都涵盖了文件的全部内容，并在可以找到不同语言内容的地方包含了特殊的 \u0026quot;外部语言元素\u0026quot;。\n一个 FileViewProvider 实例对应于一个 VirtualFile，一个 Document，并且可以检索到多个 PsiFile 实例。\n2.1 如何获得 FileViewProvider？ 从一个 VirtualFile：PsiManager.getInstance(project).findViewProvider() 从一个 PsiFile: psiFile.getViewProvider() 2.2 可以用 FileViewProvider 做什么？ 获取文件中存在 PSI 树的所有语言集：fileViewProvider.getLanguages() 获取某一特定语言的 PSI 树：fileViewProvider.getPsi(language)。例如，要获得 XML的 PSI 树，使用 fileViewProvider.getPsi(XMLLanguage.INSTANCE)。 要在文件的指定偏移处找到一个特定语言的元素：fileViewProvider.findElementAt(offset, language) 2.3 如何扩展 FileViewProvider? 要创建一个新的文件类型，该插件必须包含一个 com.intellij.fileType.fileViewProviderFactory 扩展点的扩展。\n实现 FileViewProviderFactory 并从 createFileViewProvider() 方法返回你的 FileViewProvider 实现。\n在 plugin.xml 中注册如下:\n1\u0026lt;extensions defaultExtensionNs=\u0026#34;com.intellij\u0026#34;\u0026gt; 2 \u0026lt;fileType.fileViewProviderFactory 3 filetype=\u0026#34;$file_type$\u0026#34; 4 implementationClass=\u0026#34;com.plugin.MyFileViewProviderFactory\u0026#34; /\u0026gt; 5\u0026lt;/extensions\u0026gt; 其中 $file_type$ 指的是正在创建的文件类型(例如，“JFS”)。\n3 PSI 元素 一个 PS I(程序结构接口)文件表示一个 PSI 元素的层次结构(所谓的 PSI 树)。 一个 PSI 文件(本身就是一个 PSI 元素)可能包含几个特定编程语言的 PSI 树。 反过来，一个 PSI 元素也可以有子 PSI 元素。\nPSI 元素和单个 PSI 元素层面的操作被用来探索源代码的内部结构，因为它是由 IntelliJ 平台解释的。 例如，你可以使用 PSI 元素来进行代码分析，如 代码检查 或 意图操作 。\nPsiElement 类是 PSI 元素的通用基类。\n3.1 怎么获取 PSI 元素 从一个 Action： e.getData（LangDataKeys.PSI_ELEMENT）。注意：如果当前打开了一个编辑器，并且被关注的元素是一个引用，这将返回解析该引用的结果。这可能是你需要的，也可能不是。 从一个文件中的偏移量： PsiFile.findElementAt()。注意：这将返回指定偏移量的最低级别元素（\u0026quot;叶子元素\u0026quot;），通常是一个词法标记。 最有可能的是，你应该使用 PsiTreeUtil.getParentOfType() 来找到你真正需要的元素。 通过迭代 PSI 文件：使用 PsiRecursiveElementWalkingVisitor 。 通过解析一个引用: PsiReference.resolve() 3.2 可以用 PSI 元素做什么？ 请参见 PSI Cookbook\n4. PSI 导航 有三种主要方式来进行 PSI 导航：自上而下法，自下而上法，以及引用法。\n第一种方法适用场景：你有一个 PSI 文件或另一个更高层次的元素（例如，一个方法）， 需要找到所有符合指定条件的元素（例如，所有变量声明）。\n第二种方法适用场景：你在 PSI 树中有一个特定的点（例如，位于光标所在位置的元素）， 需要找出关于它的上下文信息（例如，它被声明的元素）。\n最后，引用允许你从一个元素的使用（例如，一个方法的调用）导航到声明（被调用的方法），再返回。 引用将在一个单独的 章节 中讲述。\n4.1 自上而下导航 执行自上而下导航的最常见的方法是使用 Visitor 模式 。 要使用一个 Visitor ，你要创建一个类（通常是一个匿名的内部类），它扩展了 Visitor 类， 重写了处理元素的方法，并将 Visitor 实例传递给 PsiElement.accept() 方法。\nVisitor 的基类是特定于语言的。例如，如果需要处理 Java 文件中的元素，可以扩展 JavaRecursiveElementVisitor 并重写相关方法。\n下面的代码显示了使用 Visitor 查找所有 Java 局部变量声明的情况。\n1file.accept(new JavaRecursiveElementVisitor() { 2 @Override 3 public void visitLocalVariable(PsiLocalVariable variable) { 4 super.visitLocalVariable(variable); 5 System.out.println(\u0026#34;Found a variable at offset \u0026#34; + variable.getTextRange().getStartOffset()); 6 } 7}); 在大多数情况下，你也可以使用更具体的 API 进行自上而下的导航。例如，如果你需要获得一个 Java 类中所有方法的列表， 你可以使用一个 Visitor ，但更简单的方法是调用 PsiClass.getMethods()。\nPsiTreeUtil 包含一些通用的、独立于语言的 PSI 树状检索函数，其中一些函数（例如 findChildrenOfType() ）执行自顶向下的导航。\n4.2 自下而上导航 自下而上导航的起点是 PSI 树中的一个特定元素（例如，解析一个引用的结果）或一个偏移量。 如果已知一个偏移量，你可以通过调用 PsiFile.findElementAt() 找到相应的 PSI 元素。 这个方法返回树中最低层的元素（例如，一个标识符），如果你想确定更广泛的上下文，你需要向上导航这颗树。\n在大多数情况下，自下而上的导航是通过调用 PsiTreeUtil.getParentOfType() 进行的。这个方法在树中往上查找，直到找到你指定的类型的元素。 例如，为了找到包含的方法，你调用 PsiTreeUtil.getParentOfType(element, PsiMethod.class) 方法。\n在某些情况下，你也可以使用特定的导航方法。例如，要找到一个方法所在的类，你可以调用 PsiMethod.getContainingClass() 方法。\n下面的代码片段显示了这些调用如何一起使用。\n1PsiFile psiFile = anActionEvent.getData(CommonDataKeys.PSI_FILE); 2PsiElement element = psiFile.findElementAt(offset); 3PsiMethod containingMethod = PsiTreeUtil.getParentOfType(element, PsiMethod.class); 4PsiClass containingClass = containingMethod.getContainingClass(); 要了解导航的实际运行，请参考 代码实例 。\n5. PSI 引用 PSI 树中的引用是一个对象，它代表了从代码中某一特定元素的使用到相应声明的链接。解析一个引用意味着找到一个特定使用所指向的声明。\n最常见的引用类型是由语言语义定义的。例如，考虑一个简单的 Java 方法。\n1public void hello(String message) { 2 System.out.println(message); 3} 这个简单的代码片段包含五个引用。由标识符 String、System、out 和 println 创建的引用可以被解析为 JDK 中的相应声明： String 和 System 类、out 字段和 println 方法； println(message) 中第二次出现的 message 标识符所创建的引用可以被解析为方法参数， 在方法头中由 String message 声明。\n请注意，String message 不是一个引用，不能被解析。相反，它是一个声明。它没有引用在其他地方定义的任何名称; 相反，它自己定义一个名称。\n要解析引用--找到被引用的声明--请调用 PsiReference.resolve() 。理解 PsiReference.getElement() 和 PsiReference.resolve() 之间的区别非常重要。 前一个方法返回引用的来源，而后一个方法返回其目标。在上面的例子中，对于 message 引用，getElement() 将返回片段第二行的 message 标识符， 而 resolve() 将返回第一行（参数列表内）的 message 标识符。\n解析引用的过程与解析不同，不是同时进行的。此外，它并不总是成功的。如果当前在 IDE 中打开的代码不能编译，或者在其他情况下， PsiReference.resolve() 返回 null 是正常的，所有处理引用的代码都必须准备好处理这个问题。\n5.1 提供的引用 除了由编程语言的语义定义的引用外，IDE 还能识别由代码中使用的 API 和框架的语义决定的许多引用。请看下面的例子。\n1File f = new File(\u0026#34;foo.txt\u0026#34;); 在这里，\u0026quot;foo.txt \u0026quot;从 Java 语法的角度来看没有什么特殊的含义--它只是一个字符串。 然而，在 IntelliJ IDEA 中打开这个例子，并在同一目录下有一个名为 \u0026quot;foo.txt \u0026quot;的文件，可以按 Ctrl/Cmd+ 点击 \u0026quot;foo.txt \u0026quot;并导航到该文件。 这是因为 ID E识别了 new File(...) 的语义，并在作为参数传递给该方法的字符串提供了一个引用。\n通常情况下，引用可以被提供给那些没有自己的引用的元素，如字符串和注释。引用也经常被提供给非代码文件，如 XML 或 JSON。\n提供引用是扩展现有语言的最常见方式之一。例如，你的插件可以提供对 Java 代码的引用，尽管 Java PSI 是平台的一部分，并不需要在你的插件中定义。\n实现 PsiReferenceContributor, 在扩展点 com.intellij.psi.referenceContributor 中注册。 然后在调用 PsiReferenceRegistrar.registerReferenceProvider() 时使用 Element Patterns 指定要引用的地方。\n另请参见 引用提供指南\n5.2 具有可选或多个解析结果的引用 在最简单的情况下，一个引用会解析到一个元素，如果解析失败，代码就不正确，IDE 需要将其作为一个错误突出显示。然而，在有些情况下，情况会有所不同。\n第一种情况是软引用。考虑一下上面的 new File(\u0026quot;foo.txt\u0026quot;) 例子。如果 IDE 找不到 \u0026quot;foo.txt \u0026quot;这个文件，这并不意味着需要突出显示一个错误--也许这个文件只在运行时可用。 这样的引用从 PsiReference.isSoft() 方法返回真。\n第二种情况是多变体引用。考虑一下 JavaScript 程序的情况。JavaScript 是一种动态类型的语言，所以 IDE 不能总是精确地确定在某一特定位置正在调用哪个方法。 为了处理这个问题，它提供了一个可以被解析为多种可能元素的引用。这种引用实现了 PsiPolyVariantReference 接口。\n为了解析一个 PsiPolyVariantReference，你调用它的 multiResolve() 方法。该调用返回一个 ResolveResult 对象的数组。 每一个对象都标识了一个 PSI 元素，并且还指定了结果是否有效。例如，假设你有多个 Java 方法的重载，以及一个参数不匹配任何重载的调用。 在这种情况下，你将得到所有重载的 ResolveResult 对象，并且 isValidResult() 对所有这些对象都返回 false。\n5.3 查找引用 正如你所知，解析一个引用意味着从使用到相应的声明。要进行相反方向的导航--从声明到其使用--执行引用搜索。\n要使用 ReferencesSearch 进行搜索，需要指定要搜索的元素，以及可选择的其他参数，如需要搜索的引用的范围。 创建的 Query 允许一次获得所有的结果，或者一个一个地遍历结果。后者允许在找到第一个（匹配）结果后立即停止处理。\n5.4 实现引用 更多信息请参考 指南 和相应的 教程 。\n6. 修改 PSI PSI 是对源代码的一种读写表示，是对应于源文件结构的元素树。你可以通过添加、替换和删除 PSI 元素来修改 PSI。\n为了执行这些操作，你可以使用 PsiElement.add()、PsiElement.delete() 和 PsiElement.replace() 等方法， 以及 PsiElement 接口中定义的其他方法，这些方法可以让你在一次操作中处理多个元素，或者指定树中需要添加元素的确切位置。\n和文档操作一样，PSI 的修改需要用写操作和命令来包装（只能在事件调度线程中执行）。更多关于命令和写操作的信息，请参见 文档 。\n6.1 创建 PSI 要添加到树中或替换现有 PSI 元素的 PSI 元素通常是由文本创建的。在一般的情况下， 使用 PsiFileFactory 的 createFileFromText() 方法来创建一个新的文件，该文件包含了你需要添加到树中的代码结构， 或者作为现有元素的替换，遍历树定位你需要的位置，然后将该元素传递给 add() 或 replace() 方法。\n大多数语言都提供了工厂方法，让你更容易创建特定的代码结构。 例如，PsiJavaParserFacade 类包含诸如 createMethodFromText() 的方法，它从给定的文本中创建一个 Java 方法。\n当你实现重构、意图或检查快速修复，与现有的代码一起工作时，传递给各种 createFromText() 方法的文本会结合硬编码片段和从现有文件中提取的代码片段。 对于小的代码片段（单个标识符），你可以简单地将现有代码中的文本附加到你要构建的代码片段的文本中。 在这种情况下，你需要确保产生的文本在语法上是正确的。否则，createFromText() 方法将抛出一个异常。\n对于较大的代码片段，最好分几步进行修改。\n从文本中创建一个替换树形片段，为用户代码片段预留占位符。\n用用户代码片段替换占位符。\n用替换树替换原始源文件中的元素。\n这确保了用户代码的格式被保留下来，并且修改不会引入任何不需要的空格变化。\n参照该方法，请看 ComparingReferencesInspection 快速修复示例。\n1// binaryExpression 持有形式为 \u0026#34;x == y \u0026#34;的 PSI 表达式，需要用 \u0026#34;x.equals(y) \u0026#34;替换。 2PsiBinaryExpression binaryExpression = (PsiBinaryExpression) descriptor.getPsiElement(); 3IElementType opSign = binaryExpression.getOperationTokenType(); 4PsiExpression lExpr = binaryExpression.getLOperand(); 5PsiExpression rExpr = binaryExpression.getROperand(); 6 7// 第1步：从文本中创建一个替换片段，以 \u0026#34;a \u0026#34;和 \u0026#34;b \u0026#34;作为占位符 8PsiElementFactory factory = JavaPsiFacade.getInstance(project).getElementFactory(); 9PsiMethodCallExpression equalsCall = 10 (PsiMethodCallExpression) factory.createExpressionFromText(\u0026#34;a.equals(b)\u0026#34;, null); 11 12// 第2步：用原文件中的元素替换 \u0026#34;a \u0026#34;和 \u0026#34;b\u0026#34;。 13equalsCall.getMethodExpression().getQualifierExpression().replace(lExpr); 14equalsCall.getArgumentList().getExpressions()[0].replace(rExpr); 15 16// 第3步：用替换树替换原始文件中的一个较大的元素 17PsiExpression result = (PsiExpression) binaryExpression.replace(equalsCall); 就像 IntelliJ 平台 API 中的其他地方一样，传递给 createFileFromText()和其他 createFromText() 方法的文本必须只使用 /n 作为换行符。\n6.2 保持树结构的一致性 PSI 的修改方法并不会限制你构建结果树结构的方式。例如，在处理一个 Java 类时，你可以添加一个 for 语句作为 PsiMethod 元素的直接子元素， 尽管 Java 解析器永远不会产生这样的结构（for语句永远是 PsiCodeBlock 的子元素）代表方法体。 产生不正确的树状结构的修改可能看起来是有效的，但它们将导致后续的问题和异常。 因此，你总是需要确保你用 PSI 修改操作建立的结构与解析器在解析你所创建的代码时产生的结构相同。\n为了确保你没有引入不一致，你可以在你修改 PSI 的操作的测试中调用 PsiTestUtil.checkFileStructure（）。 这个方法可以确保你建立的结构与解析器产生的结构是一致的。\n6.3 空格和包导入 当使用 PSI 修改函数时，你不应该从文本中创建单独的空白节点（空格或换行符）。相反，所有的空白修改都由格式化处理器执行，它遵循用户选择的代码风格设置。 格式化是在每个命令的末尾自动执行的，如果需要，也可以使用 CodeStyleManager 类中的 reformat(PsiElement) 方法手动执行。\n另外，在处理 Java 代码时（或处理其他具有类似导入机制的语言的代码，如 Groovy 或 Python），你不应该手动创建导入。 相反，你应该在你生成的代码中插入完全限定的名称，然后调用 JavaCodeStyleManager 中的 shortenClassReferences() 方法（或者你正在使用的语言的同等API）。 这可以确保导入是根据用户的代码风格设置创建的，并插入到文件的正确位置。\n6.4 结合 PSI 和文件的修改 在某些情况下，你需要进行 PSI 修改，然后通过 PSI 对你刚刚修改的文档进行操作（例如，启动一个实时模板）。 在这种情况下，你需要调用一个特殊的方法来完成基于 PSI 的后期处理（如格式化），并将修改提交给文档。 你需要调用的方法叫做 doPostponedOperationsAndUnblockDocument()，它被定义在 PsiDocumentManager 类中。\n7 PSI Cookbook 本章节给出了使用 PSI（程序结构接口）的最常用操作。与开发自定义语言插件不同的是，它讲述了与现有语言（如Java）的 PSI 有关的操作。\n另请参见 《PSI 高效操作》 。\n7.1 通用 已知一个文件的名字，但不知道它的路径，如何找到它？ FilenameIndex.getFilesByName()\n如何找到一个特定的 PSI 元素在哪些地方使用？ ReferencesSearch.search()\n如何重命名一个 PSI 元素？ RefactoringFactory.createRename()\n如何重建一个虚拟文件的 PSI？ FileContentUtil.reparseFiles()\n7.2 Java 如何找到一个类的所有子类？ ClassInheritorsSearch.search()\n如何通过限定名称找到一个类？ JavaPsiFacade.findClass()\n如何通过类名找到一个类？ PsiShortNamesCache.getClassesByName()\n如何找到一个 Java 类的超类？ PsiClass.getSuperClass()\n如何获得一个 Java 类所在包的引用？ 1PsiJavaFile javaFile = (PsiJavaFile) psiClass.getContainingFile() 2PsiPackage psiPackage = JavaPsiFacade.getInstance(project) 3 .findPackage(javaFile.getPackageName()) 或\nPsiUtil.getPackageName()\n如何找到指定方法的重写方法？ OverridingMethodsSearch.search()\n全文完\n","link":"https://huangbaihua.gitee.io/post/idea/psi_intro/","section":"post","tags":["译文","IDEA插件开发"],"title":"PSI(程序结构接口)-Intellij 平台的核心抽象"},{"body":"","link":"https://huangbaihua.gitee.io/tags/%E8%AF%91%E6%96%87/","section":"tags","tags":null,"title":"译文"},{"body":"","link":"https://huangbaihua.gitee.io/categories/%E8%AF%91%E6%96%87/","section":"categories","tags":null,"title":"译文"},{"body":"基于 Gradle 开发 IntelliJ 插件是官方推荐的方式。本 Demo 使用 IntelliJ Platform Plugin Template 快速构建一个插件项目 。 利用 IntelliJ Platform 平台开发自己的第一个插件！\n5分钟 IDEA 插件开发快速入门 Demo 基于 Gradle 开发 IntelliJ 插件是官方推荐的方式。本 Demo 使用 IntelliJ Platform Plugin Template 快速构建一个插件项目 。 利用 IntelliJ Platform 平台开发自己的第一个插件！\nDemo简介 本Demo主要演示如何快速构建一个插件项目，实现一个 Action，对 IDEA 插件开发有个最基本的了解。\n本Demo目标：\n快速搭建一个插件项目 完成一个Menu Action：选中Java代码并替换成固定字符串 了解PSI概念: 编写一个 Action,弹出窗口，显示光标所在位置上的 Java 方法相关的 PSI 信息 项目结构预览\n1~5-Minutes-Demo~\\QUICK-PLUGIN-DEMO 2| .gitignore 3| build.gradle.kts 4| CHANGELOG.md 5| CODE_OF_CONDUCT.md 6| gradle.properties 7| gradlew 8| gradlew.bat 9| LICENSE 10| qodana.yml 11| README.md 12| settings.gradle.kts 13| 14+---.github 15| | dependabot.yml 16| | 17| +---ISSUE_TEMPLATE 18| | bug_report.md 19| | 20| +---readme 21| | draft-release.png 22| | intellij-platform-plugin-template.png 23| | qodana.png 24| | run-debug-configurations.png 25| | run-logs.png 26| | settings-secrets.png 27| | ui-testing.png 28| | use-this-template.png 29| | 30| +---template-cleanup 31| | | CHANGELOG.md 32| | | gradle.properties 33| | | README.md 34| | | settings.gradle.kts 35| | | 36| | \\---.github 37| | dependabot.yml 38| | 39| \\---workflows 40| build.yml 41| release.yml 42| run-ui-tests.yml 43| template-cleanup.yml 44| 45+---.idea 46| icon.png 47| 48+---.run 49| Run IDE for UI Tests.run.xml 50| Run IDE with Plugin.run.xml 51| Run Plugin Tests.run.xml 52| Run Plugin Verification.run.xml 53| Run Qodana.run.xml 54| 55+---gradle 56| \\---wrapper 57| gradle-wrapper.jar 58| gradle-wrapper.properties 59| 60\\---src 61 +---main 62 | +---java 63 | | \\---jiux 64 | | \\---net 65 | | \\---idea 66 | | \\---plugin 67 | | \\---demo 68 | | \\---action 69 | | EditorReplaceAction.java 70 | | PsiDemoAction.java 71 | | 72 | +---kotlin 73 | | \\---org 74 | | \\---jetbrains 75 | | \\---plugins 76 | | \\---template 77 | | | MyBundle.kt 78 | | | 79 | | +---listeners 80 | | | MyProjectManagerListener.kt 81 | | | 82 | | \\---services 83 | | MyApplicationService.kt 84 | | MyProjectService.kt 85 | | 86 | \\---resources 87 | +---messages 88 | | MyBundle.properties 89 | | 90 | \\---META-INF 91 | plugin.xml 92 | pluginIcon.svg 93 | 94 \\---test 95 +---kotlin 96 | \\---org 97 | \\---jetbrains 98 | \\---plugins 99 | \\---template 100 | MyPluginTest.kt 101 | 102 \\---testData 103 \\---rename 104 foo.xml 105 foo_after.xml 第一步：利用 IntelliJ Platform Plugin Template 创建项目 1# clone 项目到本地 2 3git clone git@github.com:JetBrains/intellij-platform-plugin-template.git quick-plugin-demo 4 5# 删除 github 的远程仓库地址， 切换成自己的 6 7git remote rm origin 8 9git remote add origin 自己的远程仓库地址 该步骤有可能因为墙的原因网络被中断，多试几次。\n第二步：导入项目，进行相关配置 修改配置支持Java8 gradle.properties 1 2# 插件支持的最小版本改为 202 3pluginSinceBuild=202 4#增加 2020.2版本 5pluginVerifierIdeVersions=2020.2, 2020.3.4, 2021.1.3, 2021.2.1 6# IC是社区版，这里用IU企业版 7platformType=IU 8#该版本为要求Java8的最高版本,在此之后的版本最低要求Java11 9platformVersion=2020.2 10#JDK1.8 11javaVersion=1.8 IDEA 更多版本号，参见 最新IDEA版本\nbuild.gradle.kts 1// 将 Gradle IntelliJ Plugin 的版本修改为 1.0 2id(\u0026#34;org.jetbrains.intellij\u0026#34;) version \u0026#34;1.0\u0026#34; 完成以上修改后， 重新加载项目，点击运行 Run Plugin 启动插件。 支持Java平台 默认只引入了基础平台相关的Jar包，要支持 Java 语言，需要自己添加。\ngradle.properties 1 2# 引入Java支持 3platformPlugins=com.intellij.java src/main/resources/META-INF/plugin.xml 1 2\u0026lt;idea-plugin\u0026gt; 3 4 \u0026lt;!-- 引入Java依赖 --\u0026gt; 5 \u0026lt;depends\u0026gt;com.intellij.java\u0026lt;/depends\u0026gt; 6 \u0026lt;depends\u0026gt;com.intellij.modules.lang\u0026lt;/depends\u0026gt; 7 8\u0026lt;/idea-plugin\u0026gt; 创建Java源代码目录 IDEA 插件既支持 Kotlin,Java 语言独立开发，也支持两者混合开发，写的类可以互相调用。 默认只有 kotlin 源代码目录。 Java 源代码目录需要手动创建。 创建 src/main/java 即可开始写 Java 代码了。\n默认的 kotlin 目录可以删除，但个人建议保留。 因为 kotlin 下的代码可以直接拿来做国际化，有些开源库是 kotlin 写的，可以直接 拿来用，混合开发还是比较有优势的。\n完成以上步骤后，刷新下项目，相关的依赖就加入到工程中了, 可以正式开始写代码了。\n第三步 创建一个 Action Action 是一个具有状态，展示和行为的实体。 通过继承 AnAction 重写 actionPerformed 方法实现 Action 的行为控制。 通过可选择地重写 update 方法实现 Action 的展示控制。\ncom.dmall.rdp.plugin.demo.action.EditorReplaceAction 1/** 2 * Menu Action 将代码中选中的字符替换成固定的字符 3 */ 4public class EditorReplaceAction extends AnAction { 5 /** 6 * Action 事件处理 7 * 8 * @param e 事件对象 9 */ 10 @Override 11 public void actionPerformed(@NotNull AnActionEvent e) { 12 // 获取当前工程，当前编辑器，当前文档 13 final Editor editor = e.getRequiredData(CommonDataKeys.EDITOR); 14 final Project project = e.getRequiredData(CommonDataKeys.PROJECT); 15 final Document document = editor.getDocument(); 16 17 // 获取编辑器当前光标 18 Caret primaryCaret = editor.getCaretModel().getPrimaryCaret(); 19 // 光标选中的开始位置和结束位置 20 int start = primaryCaret.getSelectionStart(); 21 int end = primaryCaret.getSelectionEnd(); 22 // 将选中的字符替换成固定字符 23 // 注意不能直接使用 document.replaceString() 方法 24 // document.replace相关操作文档的方法，不能在直接在事件处理上下文线程中执行。 25 // 而是 必须 在 写操作的上下文线程中执行，即使用 WriteCommandAction.runWriteCommandAction 方法 26 // 因为 这类文档操作 被认为是耗时的操作，不能阻塞UI事件主线程。 27 WriteCommandAction.runWriteCommandAction(project, () -\u0026gt; 28 document.replaceString(start, end, \u0026#34;~这是替换的~\u0026#34;) 29 ); 30 // 刚才替换的字符串取消选中 31 primaryCaret.removeSelection(); 32 } 33 34 /** 35 * 控制在菜单中的展示，满足以下条件时可见且可用: 36 * \u0026lt;ul\u0026gt; 37 * \u0026lt;li\u0026gt;工程打开\u0026lt;/li\u0026gt; 38 * \u0026lt;li\u0026gt;编辑器打开\u0026lt;/li\u0026gt; 39 * \u0026lt;li\u0026gt;字符串被选中\u0026lt;/li\u0026gt; 40 * \u0026lt;/ul\u0026gt; 41 * 42 * @param e Event related to this action 43 */ 44 @Override 45 public void update(@NotNull AnActionEvent e) { 46 // 获取当前工程 47 final Project project = e.getProject(); 48 // 获取编辑器 49 final Editor editor = e.getData(CommonDataKeys.EDITOR); 50 // 仅在 当前工程和编辑器不为空时(它们都处于打开的状态)，且存在选中的字符时，设置该 Menu Action 可见且可用 51 e.getPresentation().setEnabledAndVisible( 52 project != null \u0026amp;\u0026amp; editor != null \u0026amp;\u0026amp; editor.getSelectionModel().hasSelection()); 53 } 54} src/main/resources/META-INF/plugin.xml 1 2\u0026lt;actions\u0026gt; 3 \u0026lt;!-- 将此 Action 放到弹出菜单的第一个位置; 如果项目和编辑器是打开的，有字符被选中时，它总是可用的 --\u0026gt; 4 \u0026lt;action id=\u0026#34;com.dmall.rdp.plugin.demo.action.EditorReplaceAction\u0026#34; 5 class=\u0026#34;com.dmall.rdp.plugin.demo.action.EditorReplaceAction\u0026#34; 6 text=\u0026#34;选中替换\u0026#34; 7 description=\u0026#34;选中替换\u0026#34;\u0026gt; 8 \u0026lt;!-- 设置快捷键 Ctrl+Alt+G --\u0026gt; 9 \u0026lt;keyboard-shortcut keymap=\u0026#34;$default\u0026#34; first-keystroke=\u0026#34;control alt G\u0026#34;/\u0026gt; 10 \u0026lt;!-- 放到编辑器弹出菜单第一个位置 --\u0026gt; 11 \u0026lt;add-to-group group-id=\u0026#34;EditorPopupMenu\u0026#34; anchor=\u0026#34;first\u0026#34;/\u0026gt; 12 \u0026lt;/action\u0026gt; 13\u0026lt;/actions\u0026gt; 第四步 创建一个 Action 展示 PSI 信息 PSI 简介 程序结构接口(Program Structure Interface)，通常简称为PSI。 是IntelliJ平台中负责解析文件和创建语法和语义代码模型的层。\nPSI 文件 PSI 文件是一个程序逻辑结构的根，该结构将文件的内容表示为一种特定编程语言中的元素的层次结构。 PsiFile 类是所有 PSI 文件的通用基类，而特定语言的文件通常由其子类表示。 例如，PsiJavaFile 类表示一个Java文件，而 XmlFile 类表示一个XML文件\nPSI 元素 一个 PSI 文件代表了 PSI 元素（也叫 PSI 树）的层次结构。 PSI 元素表示源代码的内部结构，是由 IntelliJ 平台解析的。 在 PSI 元素上的操作一般用于代码分析，代码检查等。\nPsiElement 类是 PSI 元素的通用基类。\n有关 PSI 的更多介绍，参见 PSI\n展示 PSI 信息 com.dmall.rdp.plugin.demo.action.PsiDemoAction 1/** 2 * PSI 演示 Action，展示光标所处位置上的 PSI 元素信息。 3 * 4 */ 5public class PsiDemoAction extends AnAction { 6 @Override 7 public void actionPerformed(AnActionEvent anActionEvent) { 8 //获取当前编辑器和 PSIFile 对象 9 Editor editor = anActionEvent.getData(CommonDataKeys.EDITOR); 10 PsiFile psiFile = anActionEvent.getData(CommonDataKeys.PSI_FILE); 11 if (editor == null || psiFile == null) { 12 return; 13 } 14 //获取光标在文档中的偏移量 15 int offset = editor.getCaretModel().getOffset(); 16 final StringBuilder infoBuilder = new StringBuilder(); 17 //获取光标所在位置的 PSI 树中的元素 18 PsiElement element = psiFile.findElementAt(offset); 19 infoBuilder.append(\u0026#34;当前光标所指元素: \u0026#34;).append(element).append(\u0026#34;\\n\u0026#34;); 20 if (element != null) { 21 //查找 方法 22 PsiMethod containingMethod = PsiTreeUtil.getParentOfType(element, PsiMethod.class); 23 infoBuilder 24 .append(\u0026#34;方法: \u0026#34;) 25 .append(containingMethod != null ? containingMethod.getName() : \u0026#34;none\u0026#34;) 26 .append(\u0026#34;\\n\u0026#34;); 27 if (containingMethod != null) { 28 //查找方法所属的类 29 PsiClass containingClass = containingMethod.getContainingClass(); 30 infoBuilder 31 .append(\u0026#34;类: \u0026#34;) 32 .append(containingClass != null ? containingClass.getName() : \u0026#34;none\u0026#34;) 33 .append(\u0026#34;\\n\u0026#34;); 34 //查找方法中的本地变量 35 infoBuilder.append(\u0026#34;本地变量:\\n\u0026#34;); 36 containingMethod.accept(new JavaRecursiveElementVisitor() { 37 @Override 38 public void visitLocalVariable(PsiLocalVariable variable) { 39 super.visitLocalVariable(variable); 40 infoBuilder.append(variable.getName()).append(\u0026#34;\\n\u0026#34;); 41 } 42 }); 43 } 44 } 45 Messages.showMessageDialog(anActionEvent.getProject(), infoBuilder.toString(), \u0026#34;PSI信息\u0026#34;, null); 46 } 47 48 @Override 49 public void update(AnActionEvent e) { 50 Editor editor = e.getData(CommonDataKeys.EDITOR); 51 PsiFile psiFile = e.getData(CommonDataKeys.PSI_FILE); 52 e.getPresentation().setEnabled(editor != null \u0026amp;\u0026amp; psiFile != null); 53 } 54} src/main/resources/META-INF/plugin.xml 1 2 \u0026lt;!-- 将此 Action 放在工具菜单的最后一个位置; 如果项目和编辑器是打开的，它总是可用的 --\u0026gt; 3 \u0026lt;action 4 id=\u0026#34;com.dmall.rdp.plugin.demo.action.PsiDemoAction\u0026#34; 5 class=\u0026#34;com.dmall.rdp.plugin.demo.action.PsiDemoAction\u0026#34; 6 text=\u0026#34;查看PSI信息 \u0026#34;\u0026gt; 7 \u0026lt;!-- 放到工具菜单第后一个位置 --\u0026gt; 8 \u0026lt;add-to-group group-id=\u0026#34;ToolsMenu\u0026#34; anchor=\u0026#34;last\u0026#34;/\u0026gt; 9 \u0026lt;/action\u0026gt; 第五步运行插件，查看效果 点击 Run Plugin 或 Debug Plugin 运行插件，试着操作，查看效果。\n一些特别有用的参考 下面收集的文档对开发插件是非常有帮助的，建议深入熟悉。\n开发及API文档参考 Intellij 平台官方文档 入门参考 Intellij SDK代码示例 插件高级应用参考 Intellij IDEA 社区版源码 插件高级应用参考 IntelliJ IDEA Ultimate和其它基于IntelliJ平台的IDE发行版中包含的开源插件源码 代码质量检查类插件参考 阿里代码规范检查插件源码 插件开发必备 PSIViewer 查看PSI结构的插件 代码辅助生成类插件参考 Lombok插件源码 搜索扩展 Intellij IDEA 平台功能扩展点的开源实现代码，相当有用，能给你灵感 Intellij Platform Explorer ","link":"https://huangbaihua.gitee.io/post/idea/five_minute_quick_demo/","section":"post","tags":["原创","5分钟入门系列","IDEA插件开发"],"title":"5分钟 IDEA 插件开发快速入门 Demo"},{"body":"","link":"https://huangbaihua.gitee.io/tags/5%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97/","section":"tags","tags":null,"title":"5分钟入门系列"},{"body":"","link":"https://huangbaihua.gitee.io/categories/5%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97/","section":"categories","tags":null,"title":"5分钟入门系列"},{"body":"","link":"https://huangbaihua.gitee.io/tags/%E5%8E%9F%E5%88%9B/","section":"tags","tags":null,"title":"原创"},{"body":"","link":"https://huangbaihua.gitee.io/categories/%E5%8E%9F%E5%88%9B/","section":"categories","tags":null,"title":"原创"},{"body":"","link":"https://huangbaihua.gitee.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/","section":"tags","tags":null,"title":"系统架构"},{"body":"现代软件过度工程中的十大错误\n源文: Modern Software Over-Engineering Mistakes\n1. 工程师比业务人员更聪明 工程师认为自己是周围最聪明的人，因为他们做的创造性的工作。这第一个错误往往使得工程师过度设计。 但是，如果工程师已经计划做100件事情，业务人员总会想出第101件工程师从未想过的事情。 如果工程师解决了1000个问题，业务人员就会提出10000个问题。工程师认为自己 已经控制了一切，殊不知不知道是什么样的问题正在向他们走来。\n在我15年的编码工作中，我从未见过任何一个企业在业务需求上是\u0026quot;趋同\u0026quot;的。业务只会不一样，这是业务的本质，不是业务人员的错。\n总结 — 业务总是赢家\n提示: 如果你没有时间去看整个帖子，那么上面这一点就足够了。\n2. 可重复使用的业务功能 当业务人员不断地抛出越来越多的功能时，我们是这样看的：\n我们尽可能地对业务逻辑进行分组和归纳。这就是为什么大多数 MVC 系统最终都会出现 Fat Models 或 Fat Controllers 的原因。 但是，正如我们已经看到的，业务需求只会不同，从来都不会趋同。\n相反，我们应该这样看：\n系统中的公共逻辑和抽象往往会随着时间推移而稳定下来。它们要么保持稳定，要么随着功能的扩大而相对下降。\n例子：我们为以前的一个客户开发了一个用户档案系统。从一个具有公共功能的 CRUD 控制器开始，因为我们认为一切都将是相似的。 但是最后有13个不同的注册流程--最初的社交关系，第一次进入时的长长的注册表单，较小可编辑的页面部分， 完全不同的个人资料页面等等--以至于最后公共的东西的意义不大。 同样地，一个订单查看和订单编辑流程最终与实际的订购流程有着本质的区别。\n尽量先纵向分割业务功能，再横向分割。这适用于所有情况--孤立的服务、基于主干的服务、特定语言的模块，等等。 也有助于轻松地从一种形式切换到另一种形式。否则，改变系统的一部分会变得越来越复杂。\n总结 — 倾向于孤立而不是组合\n3. 一切都是通用的 4. 浅包装 5. 把质量当作工具来运用 6. 过度使用适配器模式综合症 7. 非功能性需求 8. 内部“发明” 9. 顺应现状 10. 错误的估计 (全文完)\n","link":"https://huangbaihua.gitee.io/post/arch/consistent-hasing/","section":"post","tags":["系统架构","译文"],"title":"现代软件过度工程中的十大错误"},{"body":"","link":"https://huangbaihua.gitee.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","section":"tags","tags":null,"title":"机器学习"},{"body":"","link":"https://huangbaihua.gitee.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","section":"categories","tags":null,"title":"机器学习"},{"body":"本文是机器学习常用算法之协同过滤算法系列篇中的第一篇，主要讲解了协同过滤的基本概念，如何求相似度，以及如何根据基于物品的协同过滤对物品进行评分。\n目录 什么是协同过滤 协同过滤分类 基于用户的协同过滤 基于物品的协同过滤 相似度 余弦相似度 皮尔逊相似度 协同过滤预测打分 物品协同过滤 参考资料 什么是协同过滤(Collaborative Filtering) 维基百科: 协同过滤（collaborative filtering）是一种在推荐系统中广泛使用的技术。 该技术通过分析用户或者事物之间的相似性（“协同”），来预测用户可能感兴趣的内容并将此内容推荐给用户。\n协同过滤实际上是一种数学方法，它通过将一个用户与所有其它用户进行比较，预测该用户给某一项目的评分。\n例如：为了预测用户A对某一特定项目的评分，首先需要计算用户A和其它所有用户的相似度。取出与用户A最相似的用户， 然后计算出用户A与所有最相似用户对这一项目的预测评分。\n协同过滤分类 基于用户的协同过滤 一般来说，通过用户的喜好特征找出与他相似的用户， 再将相似的用户对物品有相同行为（比如购买了该物品）推荐给目标客户。\n如下图所示： 用户A喜欢物品1和物品3，用户C也喜欢物品1和物品3。所以我们推测用户A和用户C有很大的相似度（喜好可能相同）。 而A对物品4还没有相关行为，所以把用户C喜欢的物品4推荐给用户A。\n基于物品的协同过滤 一般来说，通过物品的特征X找出与它相似的物品， 再将相似的物品推荐给目标客户。\n如下图所示： 用户A喜欢物品1和物品3，用户C也喜欢物品1和物品3。所以我们推测物品1和物品3有很大的相似度（特征可能相同）。 而用户B喜欢了物品1，而物品3和物品1相似，所以自动将物品3推荐给用户B。\n相似度 正如前面所讲，协同过滤不管是基于用户还是基于物品，首先都要找到相似物品或相似用户。那么如何求得用户或物品的相似度呢？本节将会做详细讲解。\n书籍评分数据 我们以推荐书籍来举例，有如下书籍评分数据（分值1-5，分值越高表示越喜欢，分值越低表示不喜欢)，分别用余弦相似度和Pearson（皮尔逊）相似度来计算用户相似度。\n用户/书籍 精益创业 会计学 微积分 育儿 投资 时间管理 情绪控制 用户A 4 - - 5 1 - - 用户B 5 5 4 - - - - 用户C 1 - - 1 - - - 用户D - 3 - - - - 3 余弦相似度 余弦相似度，也叫做余弦距离，是用向量空间中两个向量夹角的余弦值作为衡量两个个体间差异的大小的度量。根据余弦定理可以得到两个向量夹角的cos值。\n余弦值越接近1，就表明夹角越接近0度，也就是两个向量越相似，这就叫\u0026quot;余弦相似性\u0026quot;。\n现在我们依次来求书籍评分数据的用户相似度。 根据公式，用户A、用户B的相似度即为 A,B 对书籍《精益创业》的评分之积 比上A,B对7本书的评分的模。\n用户/书籍 精益创业 会计学 微积分 育儿 投资 时间管理 情绪控制 用户A 4 - - 5 1 - - 用户B 5 5 4 - - - - 用户C 1 - - 1 - - - 用户D - 3 - - - - 3 用户A,B相似度计算如下: $$ \\color{red} sim(A,B) = \\frac{ 4\\times5 }{ { \\sqrt{ 4\\times4+5\\times5+1\\times1} } \\times {\\sqrt{5\\times5+5\\times5+4\\times4}} } = 0.38 $$ 用户A,C相似度计算如下: $$ \\color{red} sim(A,C) = \\frac{ 4\\times1 + 5\\times1 }{ { \\sqrt{ 4\\times4+5\\times5+1\\times1} } \\times {\\sqrt{1\\times1+1\\times1}} } = 0.98 $$ 通过计算结果来看，sim(A,C) \u0026gt; sim(A,B) 。用户A,C的相似度 远大于 用户A,B的相似度。但通过观察上面的表格看出，用户A,B都喜欢《精益创业》这本书(评分在4分及5分)，但是A,C没有共同喜欢的书籍(C评分为1分表示不喜欢）。 所以推断A,B比A,C相似度高才对。 但是计算结果却相反，这到底是什么原因？\n从表格上看，这是因为用户对每一本书的打分在总打分的比重是不一样的。比如，用户A的总分是10分。 《精益创业》打分占比为4/10。用户B的总分为14分，《精益创业》占比为4/14。用户C的总分为2分，《精益创业》占比为1/2。\n一般来说，上面的余弦相似度计算没有把缺失的维度值考虑进去(也就是没有把用户未评分项目考虑进来)，进而给相似度计算带来了差异。\n皮尔逊相似度 为了解决余弦相似度计算带来的相似度差异问题，我们采用皮尔逊算法。皮尔逊算法比余弦距离更加重视数据集的整体性。\n该算法运用皮尔逊相关性思想计算向量余弦相似度，得到皮尔逊相关系数，它是余弦相似度在维度值缺失下的一种改进。\n皮尔逊相关性 皮尔逊是一种相关性度量方法，主要依靠计算得出的皮尔逊相关系数度量。 皮尔逊相关系数输出范围为-1到+1，0代表无相关性，负值为负相关，正值为正相关。\n几何上来讲，皮尔逊相关系数是余弦相似度在维度值缺失情况下的一种改进。 皮尔逊系数就是在使用cos计算两个向量（cos\u0026lt;a, b\u0026gt; = a • b / |a|•|b|）时进行中心化。\n皮尔逊相关系数的一般思路是，对每个向量，先计算出所有元素的平均值，然后向量中每个维度的值减去这个平均值，得到的这个向量被称为 中心化的向量。这样的操作也叫做中心化。\n注： 机器学习要计算向量余弦相似度的时候, 由于向量经常在某个维度上有数据的缺失, 预处理阶段都要对所有维度的数值进行中心化处理。\n注： 皮尔逊相关系数相关分类\n0.8-1.0 极强相关 0.6-0.8 强相关 0.4-0.6 中等程度相关 0.2-0.4 弱相关 0.0-0.2 极弱相关或无相关 求解步骤 步骤一：计算平均值 用户/书籍 精益创业 会计学 微积分 育儿 投资 时间管理 情绪控制 Mean(平均值) 用户A 4 - - 5 1 - - 10/3 用户B 5 5 4 - - - - 14/3 用户C 1 - - 1 - - - 2/2 用户D - 3 - - - - 3 6/2 步骤二: 减去平均值 用户/书籍 精益创业 会计学 微积分 育儿 投资 时间管理 情绪控制 用户A 2/3 - - 5/3 -7/3 - - 用户B 1/3 1/3 -2/3 - - - - 用户C 0 - - 0 - - - 用户D - 0 - - - - 0 步骤三: 计算余弦相似度 用户/书籍 精益创业 会计学 微积分 育儿 投资 时间管理 情绪控制 用户A 2/3 - - 5/3 -7/3 - - 用户B 1/3 1/3 -2/3 - - - - 用户C 0 - - 0 - - - 用户D - 0 - - - - 0 用户A,B的相似度 $$ \\color{red} sim(A,B) = \\frac{ \\frac2 3\\times\\frac1 3 }{ { \\sqrt{ (\\frac 2 3\\times\\frac 2 3) + (\\frac5 3\\times\\frac 5 3) + (-\\frac7 3\\times-\\frac7 3)} } \\times {\\sqrt{(\\frac1 3\\times\\frac1 3)+(\\frac1 3\\times\\frac1 3)+(-\\frac2 3\\times-\\frac2 3)}} } = 0.09 $$\n用户A,C的相似度\n用户C的评分都为0，显然A,C的相似度是0。 sim(A,C) = 0\n由此可见，这次的计算结果与之前的推断是相符的。用户A,B的相似度比A,C的相似度高。\n协同过滤预测打分 接下来，我们分别以物品和用户的维度来对物品或用户进行评分预测。\n物品协同过滤 以下是用户A-G对三本书的评分数据。 我们怎么推断用户D对《精益创业》这本书的喜欢程度呢？即评分是多少？\n- A B C D E F G 精益创业 1 - 3 ? - 5 - 会计学 - - 5 4 - - 4 微积分 2 4 - 1 2 - 3 步骤一: 求平均值\n- A B C D E F G mean 精益创业 1 - 4 ? - 5 - 10/3 会计学 - - 5 4 - - 4 13/3 微积分 2 4 - 1 2 - 3 9/4 步骤二: 减去平均值\n- A B C D E F G 精益创业 -7/3 - 2/3 ? - 5/3 - 会计学 - - 2/3 -1/3 - - -1/3 微积分 -1/4 -1/4 - -1/4 -1/4 - 1 步骤三: 分别计算物品《精益创业》(含自己)和其它所有物品的相似度 - A B C D E F G 相似度 精益创业 -7/3 - 2/3 ? - 5/3 - 1.0 会计学 - - 2/3 -1/3 - - -1/3 0.046 微积分 -1/4 -1/4 - -1/4 -1/4 - 1 0.048 $$ \\color{red}sim(精益创业,精益创业)=1 $$ $$ \\color{red}sim(精益创业,会计学)= \\frac{ \\frac2 3\\times\\frac2 3 } { { \\sqrt{ (-\\frac 7 3\\times-\\frac 7 3) + (\\frac2 3\\times\\frac2 3) + (\\frac5 3\\times\\frac5 3)} } \\times {\\sqrt{(\\frac2 3\\times\\frac2 3)+(-\\frac1 3\\times-\\frac1 3)+(-\\frac1 3\\times-\\frac1 3)}} } = 0.046 $$ $$ \\color{red}sim(精益创业,微积分)= \\frac{-\\frac7 3\\times-\\frac1 4 } { { \\sqrt{ (-\\frac 7 3\\times-\\frac 7 3) + (\\frac2 3\\times\\frac2 3) + (\\frac5 3\\times\\frac5 3)} } \\times {\\sqrt{(-\\frac1 4\\times-\\frac1 4)+(-\\frac1 4\\times-\\frac1 4)+(-\\frac1 4\\times-\\frac1 4)+(-\\frac1 4\\times-\\frac1 4)+(1\\times1)}} } = 0.048 $$\n步骤四: 根据以下公式计算评分 - A B C D E F G 评分 精益创业 1 - 3 1.65 - 5 - 1.0 会计学 - - 5 4 - - 4 0.046 微积分 2 4 - 1 2 - 3 0.048 $$ \\color{red}R14=\\frac{(0.046\\times4+0.048\\times1)} {(0.046+0.048)}=1.65 $$\n用户协同过滤 用户协同过滤和物品协同过滤原理是一样的，唯一的区别是计算时切换一下维度即可，这里就不在重复了。\n物品和用户协同过滤对比 基于物品和基于用户的原理是相同的。 基于物品很少的数据就可以预测，但是基于用户需要大量数据。 一般来讲，基于物品比基于用户更具有实践性，在实际的推荐系统中用得更多。 参考资料 《推荐系统实践》项亮 著 https://zh.wikipedia.org/wiki/%E5%8D%94%E5%90%8C%E9%81%8E%E6%BF%BE https://www.youtube.com/watch?v=h9gpufJFF-0 https://developers.google.com/machine-learning/recommendation/collaborative/matrix https://zhuanlan.zhihu.com/p/95350982 http://www.linkedkeeper.com/detail/blog.action?bid=1060 https://medium.com/@sam.mail2me/recommendation-systems-collaborative-filtering-just-with-numpy-and-pandas-a-z-fa9868a95da2 (全文完)\n","link":"https://huangbaihua.gitee.io/post/mache-learing-collaborative-filtering/","section":"post","tags":["机器学习","协同过滤","原创"],"title":"机器学习入门-算法-协同过滤简介"},{"body":"","link":"https://huangbaihua.gitee.io/tags/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4/","section":"tags","tags":null,"title":"协同过滤"},{"body":"","link":"https://huangbaihua.gitee.io/tags/hugo/","section":"tags","tags":null,"title":"Hugo"},{"body":"","link":"https://huangbaihua.gitee.io/categories/hugo/","section":"categories","tags":null,"title":"Hugo"},{"body":"","link":"https://huangbaihua.gitee.io/tags/mermaid/","section":"tags","tags":null,"title":"Mermaid"},{"body":"本文章简要描述了在Hugo中如何引入Mermaid支持以及几个简单的图例\nHugo中引入Mermaid 在 static 目录下创建 mermaid 目录, 去Mermaid上面下载 mermaid.js 并拷贝至该目录中\n在 layouts/shortcodes 目录下新建 mermaid.html 文件，内容如下\n1{{ $_hugo_config := `{ \u0026#34;version\u0026#34;: 1 }` }} 2\u0026lt;div class=\u0026#34;mermaid\u0026#34; align=\u0026#34;{{ if .Get \u0026#34;align\u0026#34; }}{{ .Get \u0026#34;align\u0026#34; }}{{ else }}center{{ end }}\u0026#34;\u0026gt;{{ safeHTML .Inner }}\u0026lt;/div\u0026gt; 在 config/_default/params.toml 文件中添加 enableMermaid 参数 1enableMermaid = true 在 layouts/partials/footer.html 中加入如下代码 1{{ if (ne .Params.enableMermaid false) }} 2\u0026lt;script src=\u0026#34;{{\u0026#34;mermaid/mermaid.js\u0026#34; | relURL}}{{ if not .Site.Params.disableAssetsBusting }}?{{ now.Unix }}{{ end }}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 3{{- end }} 在需要使用的地方使用如下代码块 1 2 {{\u0026lt; mermaid \u0026gt;}} 3 sequenceDiagram 4 participant Alice 5 participant Bob 6 Alice-\u0026gt;\u0026gt;John: Hello John, how are you? 7 loop Healthcheck 8 John-\u0026gt;John: Fight against hypochondria 9 end 10 Note right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail... 11 John--\u0026gt;Alice: Great! 12 John-\u0026gt;Bob: How about you? 13 Bob--\u0026gt;John: Jolly good! 14 {{\u0026lt; /mermaid \u0026gt;}} 以上代码渲染如下:\nsequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts prevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! 主要图例 流程图 {{\u0026lt;mermaid align=\u0026quot;left\u0026quot;\u0026gt;}} graph LR; A[Hard edge] --\u0026gt;|Link text| B(Round edge) B --\u0026gt; C{Decision} C --\u0026gt;|One| D[Result one] C --\u0026gt;|Two| E[Result two] {{\u0026lt; /mermaid \u0026gt;}} 渲染如下:\ngraph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] 序列图 {{\u0026lt; mermaid \u0026gt;}} sequenceDiagram participant Alice participant Bob Alice-\u0026gt;\u0026gt;John: Hello John, how are you? loop Healthcheck John-\u0026gt;John: Fight against hypochondria end Note right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail... John--\u0026gt;Alice: Great! John-\u0026gt;Bob: How about you? Bob--\u0026gt;John: Jolly good! {{\u0026lt; /mermaid \u0026gt;}} 渲染如下:\nsequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts prevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! 甘特图 {{\u0026lt; mermaid \u0026gt;}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d {{\u0026lt; /mermaid \u0026gt;}} 渲染如下:\ngantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d 类图 {{\u0026lt; mermaid \u0026gt;}} classDiagram Class01 \u0026lt;|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u0026gt; C2 : Where am i? Class09 --* C3 Class09 --|\u0026gt; Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u0026lt;--\u0026gt; C2: Cool label {{\u0026lt; /mermaid \u0026gt;}} 渲染如下:\nclassDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label Git {{\u0026lt; mermaid \u0026gt;}} gitGraph: options { \u0026quot;nodeSpacing\u0026quot;: 150, \u0026quot;nodeRadius\u0026quot;: 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch {{\u0026lt; /mermaid\u0026gt;}} 渲染如下:\ngitGraph: options { \"nodeSpacing\": 150, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch 参考资料 https://learn.netlify.app/en/shortcodes/mermaid/ https://github.com/matcornic/hugo-theme-learn https://mermaid-js.github.io (全文完)\n","link":"https://huangbaihua.gitee.io/post/mermaid-in-hugo/","section":"post","tags":["Hugo","Mermaid","原创"],"title":"在Hubo中使用Mermaid"},{"body":"面向领域的微服务架构-来自优步的实践。\n源文: Introduce Microservice Architecture (Adam Gluck/Uber)\n目录 简介 什么是微服务 动机 面向领域的微服务架构 优步的实现 扩展 收益 实用建议 最后的感想 简介 最近，业界围绕微服务架构，特别是微服务架构的缺陷展开了大量的讨论。仅仅几年前，正是由于微服务架构具有独立部署的灵活性，权属清晰，系统稳定性的提升，更好的关注点隔离等众多优势，很多人都欣然采用了微服务架构。但近年来，业界开始抨击微服务有大大增加系统复杂性的趋势， 有时一个微小的功能都难于构建。\n由于优步发展到约2200个核心微服务，我们采用微服务架构也经历了这些优点和缺陷之间的取舍平衡(trade off)。在过去的2年里，优步一直试图降低微服务的复杂性，同时保持微服务架构的优势。 我们希望通过这篇博文介绍我们对微服务架构的一般方法，我们称之为 \u0026quot;面向领域的微服务架构\u0026quot;(DOMA)的方法。\n虽然近些年由于这些缺陷人们对微服务架构的批评日益增多，但还是很少有人提倡完全拒绝微服务。它给运营上带来的效益太重要了，在这方面似乎还没有或部分可替代的架构。我们使用DOMA的目的是为那些想要降低整个系统复杂性的同时又能维持微服务优势的组织提供一种前进的道路。\n这篇文章解释了 DOMA 的概念, 是哪些因素导致优步会采用这种架构，它对平台和产品团队带来了哪些好处，最后是针对那些想采用这种架构的团队的一些实用建议。\n什么是微服务 微服务是面向服务架构的延伸。与2000年代规模较大的 \u0026quot;服务 \u0026quot;相比，微服务是代表一组更小范围的功能的应用程序。这些应用程序通过网络托管和提供，并暴露出一个定义良好的接口。其他应用程序通过 \u0026quot;远程过程调用\u0026quot;(RPC)来调用这个接口。\n微服务架构的关键特征是代码托管、调用和部署的方式。如果我们思考大型的单体应用，它们一般会被分割成具有明确定义接口的封装组件。这些接口就会直接在进程中调用，而不是通过网络。通过这种方式，我们也可以将微服务看作一个库，为了调用库中的所有功能有些性能影响（这些影响来自网络I/O和序列化/反序列化的开销）。\n当我们这样思考微服务的时候，可能会质疑自己为什么要采用微服务架构。答案通常是微服务可以独立部署且易于扩展。对于一个大型的单体应用，一个组织被迫一次性部署或发布所有的代码。应用程序的每一个新版本都可能涉及许多更改。部署变得风险大、耗时长。任何人都可以使整个系统瘫痪\n换句话说，组织采用微服务是为了运营效率而牺牲了性能。组织也必须承担支撑微服务所必需的维护基础设施的费用。事实证明，在多数情况下，这种取舍权衡是很有意义的，但是也强烈反对过早地采用微服务架构。\n动机 在优步，我们采用了微服务架构，因为当时(在大约2012-2013年)主要有两个单体服务，并且遇到以下诸多问题(这些问题正是微服务能解决的)。\n可用性风险。 在整个单体代码库中，一次回归就可以让整个系统(本例指优步所有系统)崩溃。\n风险大，昂贵的部署。 部署是痛苦的，耗时的，而且需要经常回滚。\n关注点分离欠佳。 很难在一个庞大的代码库中保持良好的关注点分离。在指数级增长的环境中，权宜之计有时会导致逻辑和组件之间的边界不清。\n执行效率低下。 这些问题加在一起，使团队难以自治或独立执行。\n换句话说，由于优步从10多个工程师发展到100多个工程师且拥有自己技术栈的团队时，单体架构将团队的命运捆绑在了一起并使其难以独立运作。 因此，我们采用了微服务架构。 最终结果，我们的系统变得更加灵活，这使得团队更加自治。\n系统可靠性。总体系统可靠性在微服务体架构中得到提高。单个服务可以关闭(并回滚)，而不需要关闭整个系统。\n关注点分离。从架构上讲，微服务架构迫使您问这样一个问题:“这个服务为什么存在?”，能更清晰地定义不同组件的角色。\n明确所有权。 谁拥有什么代码变得更加清晰。 服务通常在个人、团队或组织级别拥有，从而实现更快的增长。\n自主执行。独立的部署+更清晰的所有权，解锁了不同产品和平台团队的自主执行。\n开发速度。团队可以独立部署他们的代码，这使他们能够按照自己的节奏执行。\n可以毫不夸张地说，如果没有微服务架构，优步不可能实现今天保持的规模和服务质量。\n然而，随着公司规模的扩大，从100名工程师到1000名工程师，我们开始注意到一系列与大大增加系统复杂性相关的问题。 在微服务架构中，用一个可以随时更改功能黑盒替换了一个单体代码库，这样容易导致意外行为。\n例如，工程师必须通过12个不同团队的约50项服务来调查问题的根本原因。\n理解服务之间的依赖关系会变得相当困难，因为服务之间的调用层次很深，通常跨越很多层。第n个依赖关系的延迟峰值可能会导致上游的一连串问题。 如果没有合适的工具，就不可能看到实际发生的事情，这使得调试变得困难。\n为了构建一个简单的功能，工程师往往需要跨多个服务工作，所有这些服务都由不同的个人和团队拥有。 这就需要广泛的合作，在会议、设计和代码审查上花费更多的时间。 由于团队在彼此的服务中构建代码，修改彼此的数据模型，甚至代表服务所有者执行部署，早期对服务所有权的明确界限的承诺受到了影响。 网络化的单体可能会形成，看似独立的服务都必须部署在一起，才能安全地执行任何变更。\n其结果是开发者体验变慢、服务所有者不稳定、迁移更痛苦等。对于已经采用微服务架构的企业来说，已经没有回头路了。这就变成了 \u0026quot;有了它们不能活，没有它们也不能活\u0026quot;。\n面向领域的微服务架构 如果我们能把微服务看成是I/O绑定的库，把 \u0026quot;微服务架构 \u0026quot;看成是一个大型的、分布式的应用，那么我们就可以使用更好理解的架构去思考如何组织我们的代码。\n因此\u0026quot;面向领域的微服务架构\u0026quot;大量借鉴了领域驱动设计、清晰架构、 面向服务的架构、以及面向对象和接口的设计模式等成熟的代码组织方式。 我们认为DOMA的创新之处在于，它是一种相对新颖的方式，可以在大型组织的大型分布式系统中利用既定的设计原则。\nDOMA相关核心原则和术语如下：\n我们不是围绕单一的微服务，而是围绕相关微服务的集合。我们将这些称为域。我们进一步创建域的集合，我们称之为层。域所属的层建立了该域内的微服务允许承担哪些依赖关系。 我们为域提供了清晰的接口，我们将其视为进入集合的入口。我们称这些为网关。最后，我们确定每个领域对其他领域来说都是不可知的，也就是说，一个域不应该在其代码库或数据模型里面硬编码与另一个域相关的逻辑。 因为很多时候，团队确实需要在另一个团队的域中加入逻辑（例如，自定义的验证逻辑或数据模型上的一些元上下文）。 我们提供了一个扩展架构来支持领域内定义良好的扩展点。换句话说，我们提供一个系统化的架构、领域网关和预定义的扩展点。DOMA的目的是将微服务架构从复杂的东西转变为可理解的东西：一套结构化的、灵活的、可重用的、分层的组件。\n这篇文章的其余部分将挖掘优步DOMA的实施，我们看到的好处，以及对可能想要采用这种架构的公司的实用建议。\n优步的实现 领域 优步域代表了一个或多个微服务的集合，这些微服务与功能的逻辑分组相关联。在设计域的过程中，一个常见的问题是 \u0026quot;一个域应该有多大？\u0026quot; 我们在这里不给出指导。有些域可以包含几十个服务，有些域只包含一个服务。重要的任务是仔细思考每个集合的逻辑作用。 例如，我们的地图搜索服务构成了一个域，票价服务是一个域，匹配平台（匹配乘客和司机）是一个域。这些也不一定按照公司的组织结构来。 例如优步地图组织本身分为3个域，3个不同的网关，网关背后有80个微服务。\n分层设计 在优步的微服务架构中，分层设计回答了 \u0026quot;什么服务可以调用其他什么服务？\u0026quot;的问题。因此，我们可以将层设计视为 \u0026quot;规模化的关注点分离\u0026quot;。 另外，我们也可以把分层设计看作是 \u0026quot;规模化的依赖管理\u0026quot;。\n分层设计描述了一种机制，用于思考优步跨服务依赖性的故障爆炸半径和产品特异性。随着域从底层到顶层。 它们在中断时对服务的影响较小，而且代表了更具体的产品使用场景。反之。 底层的功能有更多的依赖性，因此往往有更大的障爆炸半径范围，也代表了更普遍的业务功能。 下图说明了这个概念。\n我们可以把上层看作是具体的用户体验（比如移动功能），而下层则是通用的业务功能（比如账户管理）。 层只依赖于其下的层，这给我们提供了一个有用的启发式方法来思考故障爆炸半径和领域整合等问题。\n值得注意的是，功能经常会从这个图表中 \u0026quot;向下 \u0026quot;移动，从具体到更普遍。可以想象，一个简单的功能，随着需求的发展，最终会变成越来越多的平台。 事实上，这种向下迁移是意料之中的，优步的许多核心业务平台都是从骑手或司机的特定功能开始的。 随着我们开展了更多的业务线，它们也有了更多的依赖性（如Uber Eats或Uber Freight），这些业务就变得更加普遍了。\n在优步内部，我们建立了以下五层。\n基础设施层。 提供任何工程组织都能使用的功能。这是优步对诸如存储或网络等大的工程问题的解决方案层。\n业务层。 提供了优步作为一个组织可以使用的功能，但这些功能并不针对特定的产品类别或业务线（LOB），如乘车、外卖或货运。\n产品层。 提供与特定产品类别或业务线（LOB）相关的功能，但与移动应用不可知。 如 \u0026quot;请求搭车 \u0026quot;的逻辑，这是由多个面向Rides的应用（Rider，Rider \u0026quot;Lite\u0026quot;，m.uber.com等）所组成的。\n表现层。 提供与面向消费者的应用（移动/网站）中存在的功能直接相关的功能。\n边缘层。 将优步服务安全地暴露给外界。这一层也是移动应用感知的。\n正如你所看到的，后续的每一层都代表着越来越具体的功能分组，而且爆炸半径越来越小（或换句话说，较少的组件依赖于该层内的功能）。\n网关 在微服务架构中，\u0026quot;网关API\u0026quot;这个词已经是一个广为人知的概念。除了我们倾向于把网关仅仅看作是进入底层服务集合(我们称之为域)的一个单一入口点外，我们的定义与既定的定义差别不大。一个网关的成功取决于API设计的成功。\n上图对网关进行了说明。它抽象出了域的内部细节--多个服务、数据表、ETL管道等。只有接口、RPC API、消息事件和查询暴露给其他域。\n由于上游消费者只在一个服务上运行，因此网关在未来的迁移、可发现性和整体系统复杂度方面提供了许多好处，上游服务只采取单一的依赖性，而不是依赖一个领域内可能存在的多个下游服务。 如果我们从面向对象(OO)设计的意义上考虑网关，那么它们就是接口定义，使我们能够在底层的 \u0026quot;实现\u0026quot;（这里是底层微服务的集合）方面为所欲为。\n扩展 扩展代表了一种扩展域的机制。扩展的基本定义是，它提供了一种机制，即 用于扩展底层服务的功能，而不改变该服务的实际实现，也不影响其整体可靠性。 在优步，我们提供两种不同的扩展模式：逻辑扩展和数据扩展。 扩展的概念使我们能够将我们的架构扩展到多个团队能够相互独立地工作。\n逻辑扩展 逻辑扩展提供了一种机制来扩展服务的底层逻辑。对于逻辑扩展，我们使用提供者的一个变体或插件模式，其接口是以服务为基础定义的。这使得扩展团队可以在不修改底层平台核心代码的情况下，以接口驱动的方式实现扩展逻辑。\n比如，一个司机上线。通常情况下，我们会进行各种检查，以确保司机被允许上线（安全检查、合规性等）。 其中的每一项都是由各个团队拥有的。一种实现方式是让每个团队在同一个端点中编写逻辑，但这可能会引入复杂性。 每项检查都需要自定义的、完全不相关的逻辑。\n在逻辑扩展的情况下，\u0026quot;上线 \u0026quot;端点将定义一个接口，他们希望每个扩展都能符合预定义的请求类型和响应。 每个团队会注册一个扩展，负责执行这个逻辑。 在这种情况下，他们可能会简单地获取一些关于司机的上下文，然后返回一个布尔值，说这个司机是否可以上线。 上线端点将简单地迭代这些响应，并确定其中是否有假。\n这将核心代码与每个扩展解耦，并提供扩展之间的隔离，扩展不知道其他逻辑在执行什么。 围绕着这一点，很容易建立更多的功能，比如可观察性或特性标记。\n数据扩展 数据扩展提供了一种将任意数据附加到接口的机制，以避免核心平台数据模型的臃肿。 对于数据扩展，我们利用Protobuf的Any功能，这样团队就可以将任意数据添加到请求中。 服务通常会存储这些数据或将其传递给逻辑扩展，这样核心平台就永远不会负责反序列化（从而 \u0026quot;知道\u0026quot;）这个任意上下文。 Protobuf的任何实现都会有一些基础设施开销，以换取更强的类型化。 为了更简单的实现，我们可以很容易地使用JSON字符串来表示任意数据。\n自定义 在逻辑和数据扩展之外，优步的很多团队都推出了自己适合自己领域的扩展模式。 例如，与我们的展示架构绑定的很多集成都使用了基于DAG的任务执行逻辑。\n收益 优步的几乎每个主要领域都在一定程度上受到了DOMA的影响。在过去的一年里，我们主要关注优步的业务层，它为我们的各个业务领域提供了通用的逻辑。\nDOMA在优步还很年轻，我们很高兴能在未来分享更多数据和深入的架构案例。 不过，在简化开发者体验和降低整体系统复杂度方面，早期的影响非常积极。\n产品和平台 DOMA是优步整个产品和平台团队达成共识的结果。平台支持成本往往下降了一个数量级。产品团队从明确的权责边界和加快地开发中受益。\n例如，我们扩展架构的一个早期平台服务消费者能够将一个新功能的优先级和集成时间从三天下降到三个小时。 通过采用扩展架构，减少代码审查、规划的时间，以及服务消费者的学习曲线。\n降低复杂度 以前产品团队需要调用许多下游服务来利用一个领域，现在他们只需要调用一个服务。通过减少上线一个新功能的服务数量。 平台能够减少25-50%的上线时间。此外，我们能够将2200个微服务划分为70个领域。其中大约50%的服务已经实现。 并且大部分已经计划在未来采用。\n未来的迁移 在优步，我们计算过微服务的半衰期是1.5年，也就是说每1.5年我们就有50%的微服务流失。 如果没有网关，微服务架构很容易因为这种流失而陷入 \u0026quot;迁移地狱\u0026quot;。不断变化的微服务需要不断进行上游迁移。 网关使团队能够避免对底层领域服务的依赖，这意味着这些服务可以在不强制进行上游迁移的情况下发生变化。\n优步在去年最大的两次平台改版都发生在网关背后。这些平台上有数百个依赖于它们的服务，它们将不得不迁移现有的服务消费者。 在这些情况下，迁移的成本会非常高，使得重写整个平台不可行。\n新业务线和产品 事实证明，使用DOMA设计的平台可扩展性更强，也更容易维护。 优步的大多数团队采用DOMA是因为支持新业务线的成本太高。\n实用建议 本节为可能想采用DOMA的公司提供一些实用的建议。 这里的指导原则是，根据我们的经验，一个成熟的、经过深思熟虑的微服务架构源于在正确的时间向正确的方向不断推进。 现实情况是，对于一整个微服务架构来说，真正的 \u0026quot;重写 \u0026quot;是永远不可能的。\n因此，我们认为发展微服务架构更像是 \u0026quot;修剪篱笆\u0026quot;，使其最终正确地生长。 而不是自上而下或一次性的架构（或重新架构）工作。这是一个动态和渐进的过程。\n创业公司 正如我们在上面看到的那样，首先要提出这样的问题， \u0026quot;我们应该在什么时候采用微服务架构？\u0026quot;和 \u0026quot;它对我们的组织有意义吗？\u0026quot; 虽然微服务为拥有大量工程师的组织提供了操作上的好处，但这也带来了复杂性的增加，使功能的构建更加困难。\n在小型组织中，运营效益可能无法抵消架构复杂性的增加。此外，微服务架构往往需要专门的微服务系统。 工程资源的支持，这可能超出了早期公司的预算，或者从优先级的角度来看是次优的。\n考虑到这一点，在一段时间内完全暂缓采用微服务也不是没有道理的。如果一个组织真的选择采用微服务。 它应该思考 \u0026quot;微服务作为大型分布式应用 \u0026quot;的类比，以及它想要构建的微服务之间的关注点分离。 另外，要认识到第一批微服务很可能是最重要的，也是持续时间最长的，因为它们真正描述了核心业务。\n中等规模公司 一旦公司发展到中等规模，拥有多个团队，不同的功能和平台之间的关注点明确划分就会变得模糊。这时微服务架构的作用就更加明显。\n在这个阶段，人们可以开始考虑微服务之间的层次结构。 因为一些服务开始对业务运营变得更加关键，越来越多的团队依赖这些服务，依赖性管理也就可能变得越发重要。\n早期对平台化的投资可能会在未来得到回报。 如果能建立产品完全不可知的业务平台，避免核心平台服务中的任意产品逻辑，才可能避免技术债务。 此时采用扩展来实现这一目标或许是有意义的。\n鉴于微服务的数量可能还相当少，将它们集中在一起可能没有意义。 不过，这里值得注意的是，在优步的DOMA实现背景下，一个领域可以包含一个服务，所以用 \u0026quot;面向领域 \u0026quot;的方式来思考可能还是有用的。\n大公司 大公司一般都有规模较大的工程团队，团队可能有数百名工程师和数百个微服务以及众多的依赖关系。这时DOMA就能起到全部作用。 这时会存在众多的微服务集群，这些集群可以很容易地归为域，在它们前面有一个网关。 之前遗留的服务往往开始需要重构或重写，然后进行迁移，这时网关将很快会在服务的迁移便利性方面提供应有的作用。\n一些特定功能或分组的功能会作为“产品”服务来运行，被看作“平台”的其它服务会越来越多地支持多个产品， 此时明确的层次结构将变得越来越重要。 现阶段，保持任意产品逻辑与平台脱钩至关重要。以免给平台团队带来沉重的运营负担以及造成全系统的不稳定。\n最后的感想 随着优步越来越多的团队采用DOMA，我们仍在积极地发展DOMA。DOMA理解微服务架构的关键点在于它把该架构也只是看作一个大的分布式应用程序而已，同样的原则也可以应用于其它架构的进化，就像你应用到其它任何软件一样。 DOMA只是一种在实践中思考这些原则的方法。我们希望其他人觉得它有用，我们也期待着反馈!\nDOMA本身是一个跨职能部门合作的成果，有近60位工程师参与，他们来自优步的各个部门。特别要感谢的是，在过去2年里为这项工作投入大量精力的人......。\nAlex Zylman, Alexandre Wilhelm, Allen Lu, Ankit Srivastava, Anthony Tran, Anupam Dikshit, Anurag Biyani, Daniel Wolf, Davide D’Agostino, Deepti Chedda, Dmitriy Bryndin, Gaurav Tungatkar, Jacob Greenleaf, Jaikumar Ganesh, Jennie Ngyuen, Joe McCabe, Joshua Shinavier, Julia Law, Kusha Kapoor, Linda Fu, Madan Thangavelu, Nimish Sheth, Parth Shah, Shawn Burke, Simon Newton, Steve Sherwood, Uday Kiran Medisetty, and Waleed Kadous\n#鸣谢:\n这项工作将业界现有的多种设计模式用来解决优步的问题，同时也提出了类似扩展的新模式。 我们感谢业界做出的工作。我们也感谢领英的工程师们在“Superblocks”的工作，他们向我们讲述了他们的相关经验。\n(全文完)\n","link":"https://huangbaihua.gitee.io/post/microservice-architecture/","section":"post","tags":["系统架构","微服务","译文"],"title":"面向领域的微服务架构-来自优步的实践"},{"body":"","link":"https://huangbaihua.gitee.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/","section":"tags","tags":null,"title":"微服务"},{"body":"源文: CAP Theorem: Revisited (Robert Greiner)\n在当今的技术环境中，当需要更多的资源(计算，存储等)以在合理的时间范围内成功完成工作负载时，对系统进行横向扩展变得尤为迫切,我们正目睹这类需求不断地增长。 正是由于这种扩展策略，在系统中引入了额外的复杂性。 这正是 CAP 定理要解决的问题。\nCAP 定理指出，在一个分布式系统中(共享数据的互联节点的集合)，在一次读写操作中，你只能获得，一致性，可用性，分区容错性这三个保证中的二个，必须牺牲其中的一个。 然而，正如接下来你看到的那样，你能选择的并不像你想象的那么多。\n一致性(Consistency) - 对于给定的客户端，保证读取返回最新的写入。 可用性(Availability) - 非故障节点能在合理的时间范围内返回合理的响应（没有错误或超时）。 分区容错性(Partition Tolerance) - 当网络分区发生时，系统能继续运行。 [译者注]\n分区，来自知乎的定义: 一个分布式系统里面，节点组成的网络本来应该是连通的。然而可能因为一些故障，使得有些节点之间不连通了，整个网络就分成了几块区域。数据就散布在了这些不连通的区域中。 这就叫分区。当一个数据项只在一个节点中保存，那么分区出现后，和这个节点不连通的部分就访问不到这个数据了。这时分区就是无法容忍的。 然而，要把数据复制到多个节点，就会带来一致性的问题，就是多个节点上面的数据可能是不一致的。要保证一致，每次写操作就都要等待全部节点写成功，而这等待又会带来可用性的问题。 总的来说就是，数据存在的节点越多，分区容忍性越高，但要复制更新的数据就越多，一致性就越难保证。为了保证一致性，更新所有节点数据所需要的时间就越长，可用性就会降低。\n在继续之前，我们需要先明确一件事。面向对象编程不等于网络编程。在构建共享内存的应用程序时，有一些我们认为理所当然的假设，一旦节点被跨空间和时间分割后，这些假设就会被打破。\n网络是可靠的就是这样一个分布式计算的谬论。 网络是不可靠的！ 网络和部分网络会经常意外发生故障。 网络故障在你的系统中迟早会发生，但是故障何时发生是由不得你选择的。\n[译者注]\n分布式8大谬论 来自维基百科\n网络是可靠的 The network is reliable; 没有延迟 Latency is zero; 带宽是无限的 Bandwidth is infinite; 网络是安全的 The network is secure; 网络拓扑不会改变 Topology doesn't change; 系统只有一位管理员 There is one administrator; 信息传输成本为零 Transport cost is zero; 网络都是同质的 The network is homogeneous. 鉴于网络不是完全的可靠，在分布式系统中你必须容忍分区。幸运的是当分区分生时，你可以选择如何来做。根据CAP理论，意味着我们还有一致性和可用性两项可选。\nCP - 一致性/分区容错性 - 等待来自分区节点的响应会导致超时发生。 系统可以选择返回一个错误，这取决于你想要的场景。 当业务需求规定原子读写时，选择一致性而不是可用性。 AP - 可用性/分区容错性 - 返回你所拥有数据的最新版本，数据可能是过时的。该系统状态也可以接受在分区问题解决之后再处理写操作。当你的业务需求允许数据在系统同步时可以有一定的弹性时选择可用性 而不是一致性。当系统需要在外部错误发生时（购物车等）继续运行时，可用性也是一个令人信服的选择。 在一致性和可用性作出选择是一种软件平衡。在面对网络分区时你可以自己选择如何处理，控制权在你手上。不管是暂时的还是永久的网络故障，都是生活的一部分，不管你愿不愿意，它总会发生，它存在于软件之外。 构建分布式系统提供了许多优势，但是也增加了复杂性。面对网络错误时,理解可用的平衡，并作出正确的选择对你的应用成功至关重要。 如果不能从一开始就做到这一点，那么在第一次部署应用之前，你的应用程序就会失败。\n(全文完)\n","link":"https://huangbaihua.gitee.io/post/cap-theorem/","section":"post","tags":["系统架构","分布式","译文"],"title":"CAP理论简介"},{"body":"","link":"https://huangbaihua.gitee.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/","section":"tags","tags":null,"title":"分布式"},{"body":"","link":"https://huangbaihua.gitee.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/","section":"categories","tags":null,"title":"系统架构"},{"body":"","link":"https://huangbaihua.gitee.io/tags/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/","section":"tags","tags":null,"title":"技术管理"},{"body":"","link":"https://huangbaihua.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/","section":"categories","tags":null,"title":"技术管理"},{"body":"Bob(编程界骨灰级人物)的清晰架构。\n源文: The Clean Architecture (Robert C. Martin (Uncle Bob)\n在过去的几年里，我们看到了一系列关于系统架构的想法。这些包括：\nAlistair Cockburn 提出的六边形架构(又称端口和适配器架构),Steve Freeman和Nat Pryce在他们精彩的《测试驱动的面向对象软件开发》\u0026quot;一书中有应用 Jeffrey Palermo 的洋葱架构 作者本人去年提出的Screaming Architecture DCI,James Coplien和Trygve Reenskaug BCE,Jacobson《面向对象软件工程》：一种用例驱动的方法 这些架构尽管细节不同，但都大同小异。它们都有着相同的目标，即关注点分离(separation of concerns)。它们都通过一种软件分层的方法来实现这种分离，至少有一层业务规则层，一层接口层。\n每种架构都会产生具有如下特点的系统：\n不依赖框架。架构不依赖这些功能丰富的软件库，使得系统仅将框架当工具使用，而不是将你的系统融入到框架的限制之中。 可测试的。业务层可以在没有界面，数据库，Web 服务器和其它任何外部元素情况下进行测试。 不依赖界面。不需要修改系统的其它部分，就能很容易的修改界面。例如，不需要修改业务逻辑，一个 Web 界面可以替换成控制台界面。 不依赖数据库。你可以把 Oracle 或者 SQL Server 换成 Mongo、BigTable、CouchDB 或者其他。业务逻辑不受数据库的约束。 不依赖任何外部元素。实际上系统的业务规则不关心外部世界。 本文最上面的图试图将这些架构的想法综合总结成一种可操作的规则。\n依赖规则 图中同心圆代表软件的不同领域。一般来说，越往里走，软件的层次越高。外层是机制。内层是策略。\n使这个架构发挥作用的首要规则是依赖规则。该规则明确源代码依赖只能指向内层依赖。内层不能知道外层，特别是，外层声明的一些命名不能被内层的代码提及，包括函数，类，变量或任何其它命名的软件实体。\n同样的道理，外层使用的数据格式不能用于内层，尤其是这些格式是由外层的框架生成的时候。我们不希望外层的东西影响到内层。\n实体 实体封装了企业范围内 (Enterprise Wide) 的业务规则。 一个实体可以是一个带有方法的对象，也可以是一组数据结构和函数。只要实体可以被企业中的许多应用所使用到，其它都不重要。\n如果没有企业，只是在编写一个单一的应用程序，那么这些实体就是应用程序的业务对象。它们封装了最通用和高级的规则。当外部事物发生变化时，它们是最不可能改变的。\n例如，你不会期望这些对象会受到页面导航或安全性的变化的影响。任何特定应用程序的操作变化都不应该影响实体层。\n用例 该层包含了特定应用 (application specific) 的业务规则。它封装并实现了系统的所有用例。这些用例协调进出实体的数据流，并指导实体使用企业范围内 (Enterprise Wide) 业务规则来实现用例的功能。\n我们不希望这一层的变化会影响实体。我们也不希望这一层的变化会受到外部的影响，如数据库、界面或任何常见框架。这一层与这些关注点是隔离的。\n但是，应用程序的操作变化会影响到用例，从而影响到这一层。如果一个用例的细节发生变化，那么这一层的一些代码肯定会受到影响。\n接口适配 该层是组适配器,它将数据从对用例和实体最方便的格式转换为对一些外部机构（如数据库或 Web ）最方便的格式。\n例如，在这一层，包含 GUI 的整个 MVC 架构层，表示层，界面层，控制器都在这一层。模型很可能只是数据结构，从控制器传递到用例，再从用例传回给表示层和界面层。\n同样，在这一层中，数据也被从对实体和用例最方便的形式转换为对任何持久化框架最方便的形式，即数据库。在这一层中，任何代码都不应该对数据库有任何了解。\n如果数据库是一个 SQL 数据库，那么所有的 SQL 应该限制在这一层，特别是这一层中与数据库有关的部分。\n另外，在这一层中还有任何其他必要的适配器，以便将数据从一些外部形式（如外部服务）转换为用例和实体使用的内部形式。\n框架和驱动 最外层一般由框架和工具组成，如数据库、Web 框架等。一般在这一层除了写一些与内层通讯的胶水代码外，你不会写太多代码。\n这一层是所有的细节所在。Web是一个细节。数据库是一个细节。我们把这些东西放在最外层，在这一层它们不会对内层造成什么影响。\n只有四层? 不，这四层仅仅是示意图。你可能会发现你需要的不仅仅是这四层，没有规定说你必须永远只有这四层，然而，\u0026quot;依赖性规则 \u0026quot;总是适用的。源代码的依赖性总是向内指向。 越向内层，抽象程度也会增加。最外层是低级的具体实现细节。随着向内层移动，软件越来越抽象，并封装了更高层次的策略。最内层是最抽象的(The inner most circle is the most general)。\n跨越边界 在图的右下方是我们如何跨越层边界的一个例子。它显示了控制器和展示层与下一层的用例进行通讯。请注意控制的流程。它从控制器开始，经过用例，然后最终在展示层执行。还请注意源代码的依赖关系。它们中的每一个都向内指向用例。\n我们通常通过使用依赖反转原则来解决这个明显的矛盾。例如，在像Java这样的语言中，我们会安排合理的接口和继承关系，使源代码的依赖关系在恰当的点上不让控制流跨越边界。\n例如，考虑用例需要调用表示层。但是，这个调用一定不能是直接的，因为那会违反依赖规则。外层的名字不能被内层的名字所提及。所以，我们让用例调用内层中的一个接口（这里显示为用例输出端口），并让外层中的表示层去实现它。\n同样的技术被用来跨越架构中的所有边界。我们利用动态多态的优势，创建与控制流相反的源代码依赖关系，这样无论控制流向哪个方向，我们都能符合 \u0026quot;依赖规则\u0026quot;。\n哪些数据跨越边界 通常情况下，跨越边界的数据是简单的数据结构。如果你喜欢的话，你可以使用基本结构或者简单的数据传输对象。或者数据可以简单地成为函数调用中的参数。或者你可以把它打包成一个哈希图，或者构造成一个对象。重要的是，隔离的、简单的、数据结构是跨边界传递的。我们不希望直接传递实体或数据库行。我们不希望数据结构有任何违反依赖规则的依赖关系。\n例如，许多数据库框架在响应查询时都会返回一个方便的数据格式。我们可以将其称为行结构(RowStructure)。我们不希望将这个行结构向内传递到一个边界上。这将违反依赖规则，因为它会迫使内层知道一些关于外层的事情。\n所以当我们跨边界传递数据时，总是以对内层最方便的形式传递。\n结论 遵循这些简单的规则并不难，而且会让你在今后的工作中省去很多麻烦。通过将软件分成若干层，并遵守依赖规则，你可以创建一个本质上可测试的系统，并带来所有的好处。 当系统中的任何外部依赖部分过时时，比如数据库或网络框架，你可以用最少的代价替换这些过时的依赖。\n(全文完)\n","link":"https://huangbaihua.gitee.io/post/the-clean-architecture/","section":"post","tags":["系统架构","译文"],"title":"清晰架构"},{"body":"最近我碰到过几次使用一致性哈希的情况。介绍这个概念的论文《一致性哈希和随机树：分布式缓存协议，用于解决互联网应用中的热点问题。David Karger等人著》 出现在十年前，不过最近似乎这个概念已经悄悄地应用到从亚马逊的\u0026quot;Dynamo\u0026quot;到Last.fm提供的\u0026quot;Memcached\u0026quot;等越来越多的服务当中。那么，什么是一致性哈希，为什么要关心它？\n源文: Consistent Hashing (Tom White)\n对一致性哈希的需求来自于多个缓存服务器缓存对象一些限制--例如，Web缓存。想象这样的场景，在使用n台缓存服务器(编号1到n)时， 一种常用的负载均衡方式是,对资源对象o的请求使用hash(o)先取哈希值，然后对n取模(mod n)， 这样得到的值(hash(o) mod n)就是对应缓存服务器的编号，该缓存就会放在对应编号的缓存服务器上。 这工作良好，直到你添加或删除缓存服务器（无论出于什么原因），因为此时n发生了变化，每个对象都会被哈希到一个新的位置。这可能是灾难性的，这会使得缓存服务器大量集中地向原始内容服务器更新缓存，从而造成服务器的瘫痪。 这就好像缓存突然消失了一样。从某种意义上来说，它已经消失了。这就是为什么你应该关心一致性哈希的原因：需要一致哈希算法来避免这样的问题！\n如果添加一台缓存服务器时，它应该能从所有其他缓存服务器中获取它应得的对象；同样，当移除一台时，它的对象应该能被其余的服务器共享。 这正是一致性哈希所做的事情--将对象一致地映射到同一台缓存服务器上，至少在可能的情况下，是这样的。\n一致性哈希算法背后的基本思想是使用相同的哈希函数对对象和缓存进行哈希。这样做的原因是将缓存映射到一个区间，这个区间将包含一些对象哈希。如果缓存被移除，那么它的区间就会被一个具有相邻区间的缓存接管。所有其他缓存保持不变。\n证明 我们来详细看看这个问题。哈希函数实际上是将对象和缓存映射到一个数字范围。这应该是每个Java程序员都熟悉的: Object上的hashCode方法返回一个整数，它位于-2 31到2 31-1的范围内。 想象一下，把这个范围的数值环绕起来，就映射成了一个圆。下面是一张圆的图片，在它们哈希到的点上标记了一些对象（1、2、3、4）和缓存（A、B、C）（基于David Karger等人的《具有一致哈希的Web缓存》中的一张图）。\n为了找到一个对象的缓存位置，我们顺时针绕着圆移动，直到找到一个缓存点。所以在上图中，我们看到对象1和4属于缓存A，对象2属于缓存B，而对象3属于缓存C。 考虑一下如果缓存C被删除会发生什么：对象3现在属于缓存A，而所有其他对象的映射没有变化。如果再在标记的位置增加一个缓存D，它将带走对象3和4，只留下属于A的对象1。\n这样做的效果很好，只是分配给每个缓存的间隔大小很不理想。由于本质上是随机的，所以有可能在缓存之间的对象分布非常不均匀。 解决这个问题的方法是引入 \u0026quot;虚拟节点 \u0026quot;的概念，虚拟节点是圆内缓存点的复制。所以每当我们添加一个缓存时，我们就会为它在圆中创建一些点。\n你可以在下面的图中看到这个效果，这是我用下面描述的代码模拟在10个缓存中存储10000个对象而制作的。 在x轴上是缓存点的复制数(虚拟节点)（用对数刻度）。当它很小的时候，我们看到对象在各缓存中的分布是不平衡的，因为标准差作为每个缓存的平均对象数的百分比（在y轴上，也是对数）很高。 随着复制数(虚拟节点)的增加，对象的分布变得更加平衡。这个实验表明，一两百个副本(虚拟节点)的数字可以达到一个可接受的平衡（标准偏差大致在平均值的5%到10%之间）。\n实现 这里是一个简单的Java实现。为了使一致性哈希有效，拥有一个能很好散列的哈希函数是很重要的。 Object的hashCode的大多数实现都不能很好地散列--例如，它们通常会产生数量有限的小整数值--所以我们有一个HashFunction接口来允许使用自定义的哈希函数。这里推荐使用MD5哈希。\n1import java.util.Collection; 2import java.util.SortedMap; 3import java.util.TreeMap; 4 5public class ConsistentHash\u0026lt;T\u0026gt; { 6 7 private final HashFunction hashFunction; 8 private final int numberOfReplicas; 9 private final SortedMap\u0026lt;Integer, T\u0026gt; circle = 10 new TreeMap\u0026lt;Integer, T\u0026gt;(); 11 12 public ConsistentHash(HashFunction hashFunction, 13 int numberOfReplicas, Collection\u0026lt;T\u0026gt; nodes) { 14 15 this.hashFunction = hashFunction; 16 this.numberOfReplicas = numberOfReplicas; 17 18 for (T node : nodes) { 19 add(node); 20 } 21 } 22 23 public void add(T node) { 24 for (int i = 0; i \u0026lt; numberOfReplicas; i++) { 25 circle.put(hashFunction.hash(node.toString() + i), 26 node); 27 } 28 } 29 30 public void remove(T node) { 31 for (int i = 0; i \u0026lt; numberOfReplicas; i++) { 32 circle.remove(hashFunction.hash(node.toString() + i)); 33 } 34 } 35 36 public T get(Object key) { 37 if (circle.isEmpty()) { 38 return null; 39 } 40 int hash = hashFunction.hash(key); 41 if (!circle.containsKey(hash)) { 42 SortedMap\u0026lt;Integer, T\u0026gt; tailMap = 43 circle.tailMap(hash); 44 hash = tailMap.isEmpty() ? 45 circle.firstKey() : tailMap.firstKey(); 46 } 47 return circle.get(hash); 48 } 49 50} 哈希圆用排序的整形映射来表示，整数代表映射到缓存的哈希值（这里是T类型）。 当一个ConsistentHash对象被创建后，每个节点都会被添加到圆中若干次（由numberOfReplicas控制）。每个副本(虚拟节点)的位置是通过对节点的名称和数字后缀进行哈希来选择的，节点被存储在图中的这些点上。\n要找到一个对象的节点（get方法），就要用对象的哈希值在圆中寻找。大多数情况下，在这个哈希值处不会存储有节点（因为哈希值空间通常比节点数量大得多，即使是复制点也是如此）， 所以通过在映射末尾寻找第一个键来找到下一个节点。如果映射末尾是空的，那么我们就通过获取圆的第一个键。\n使用 那么如何使用一致性哈希算法呢？ 使用现成的库，而不是要自己编码。比如上面提到的Memcached，一个分布式内存对象缓存系统，现在已经有支持一致性哈希的客户端。 如最初的ketama哈希算法，作者是Last.fm公司的Richard Jones；现在还有Dustin Sallings的Java实现（这启发了我上面的简化演示实现）。 有趣的是，只有客户端需要实现一致性哈希算法--Memcached服务器是不需要的。其他采用一致性哈希的系统包括Chord，它是一个分布式哈希表的实现，以及Amazon的Dynamo，它是一个键值存储（在Amazon之外无法使用）。\n(全文完)\n","link":"https://huangbaihua.gitee.io/post/consistent-hasing/","section":"post","tags":["系统架构","译文"],"title":"一致性哈希"},{"body":"这是一份经过精心整理的阅读清单，它详细说明了在大型系统中如何保障系统的可伸缩性，可靠性以及高性能的常见模式。 该阅读清单由知名工程文章及来源可靠的资源组成。 这些内容对可伸缩性等相关概念均有很好的阐述。清单中研究的案例也 都来自于服务于数百万，乃至数十亿用户且经过实战检验过的系统。\n源文: Awesome Scalability\n内容 原则 可扩展性 可用性 稳定性 性能 智能 架构 面试 组织 访谈 书籍 原则 巨型服务的经验教训--加州大学伯克利分校和谷歌公司的Eric Brewer 构建大型分布式系统的设计、经验和建议 - Jeff Dean, Google 如何设计一个好的API以及它的重要性--Joshua Bloch，CMU和Google。 关于效率、可靠性、扩展--James Hamilton，AWS公司副总裁 构建企业平台时应注意的事项 - Heidi Williams，Box公司平台副总裁 混沌工程原理 在混沌中寻找秩序 十二要素应用 清晰架构 高内聚、低耦合 单体和微服务 CAP定理和权衡 CP 数据库 和 AP 数据库 无状态与有状态的可伸缩性 垂直伸缩和水平伸缩 垂直伸缩对比水平伸缩: 隐形成本 ACID 与 BASE 阻塞/非阻塞 和 同步/异步 数据库的性能和可伸缩性 数据库隔离级别及对性能和可扩展性的影响 大型集群中数据丢失的概率分析 高可扩展解决方案的数据访问。使用SQL、NoSQL和Polyglot持久性技术 SQL vs NoSQL SQL vs NoSQL - Salesforce的经验教训 NoSQL 数据库: 调查和决策指南 分片是如何工作的 一致性哈希 一致性哈希：算法权衡 不要被哈希技巧所欺骗 在Netflix的统一一致的哈希 最终一致性 - Werner Vogels,Amazon公司CTO 缓存为王 反缓存 理解延迟 每一个程序员都应该知道的延迟数字 服务可用性微积分 扩展Web应用时的架构问题。瓶颈、数据库、CPU、IO 常见瓶颈 分布式交易背后的秘密 依靠软件在不同层级可靠地重定向流量 有目的的打破固有事物 避免过度工程 可伸缩性最差实践 使用稳定的技术--不要重新发明轮子--保持简单! Simplicity by Distributing Complexity 为什么过度重用是坏事 性能是一个特性 让性能成为工作流程的一部分 服务器端渲染比客户端渲染的优点 自动化和抽象：Facebook的教训 AWS的做与不做 UI设计不可伸缩性 - Stanley Wood, Design Director at Spotify Linux 性能 构建快速而有弹性的Web应用 - Ilya Grigorik 接受部分故障，将服务损失降到最低限度 弹性设计 自我修复设计 水平伸缩设计 演化设计 从错误中学习 可伸缩性 微服务和服务编排 Uber公司面向领域的微服务架构 Riot Games的容器 (8部分)实践 容器化在Pinterest的应用 容器在Netflix使用的演变 在Uber实现MySQL的Docker化 Spotify的微服务测试 Treehouse的在生产中Docker实践 SoundCloud的微服务 在Stripe可靠地运行Kubernetes 在Trivago使用Istio进行跨集群流量镜像 英国广播公司的Nanoservices PowerfulSeal: 彭博社Kubernetes集群的测试工具 Conductor: Netflix的微服务编排 Docker容器为Shopify的100.000多个在线商店提供支撑 Medium公司的微服务架构 From bare-metal to Kubernetes at Betabrand Tinder公司的K8s实践 Quora公司的K8s实践 Pinterest公司的K8s平台 Nubank的微服务实践 GRIT: eBay跨微服务的分布式协议 Rubix: Palantir的K8s实践 分布式缓存 EVCache: Netflix的分布式内存缓存技术 EVCache Cache Warmer基础架构在Netflix的应用 Memsniff: Box公司强大的Memcache流量分析器 Caching with Consistent Hashing and Cache Smearing at Etsy Facebook的图片缓存分析 在Facebook的缓存效率练习 tCache: Scalable Data-aware Java Caching at Trivago Pycache: Quora的进程内缓存 在Trivago将Memcached内存使用量减少50% 缓存内部服务,Yelp公司 在Allegro使用大数据估算缓存效率 Zalando的分布式缓存 NetFlix公司从RAM到SSD的应用数据缓存化 Skyscanner重复缓存的权衡 Avoiding Cache Stampede at DoorDash 在Yext使用Quadtrees进行位置缓存 Vimeo的视频元数据缓存功能 在Twitter上扩展Redis 在Slack上使用Redis扩展作业队列 在Github上将持久性数据从Redis中移出 在Instagram的Redis中存储数以亿计的简单键值对 Trivago公司的Redis实践 优化Deliveroo的Redis存储 Redis中的内存优化在Wattpad上的应用 Redis Fleet at Heroku 在SoundCloud解决远程构建缓存缺失的问题（2部分） Prefetch Caching of Items at eBay HTTP缓存和CDN Zynga Geo Proxy: Reducing Mobile Game Latency at Zynga Google AMP at Condé Nast A/B Tests on Hosting Infrastructure (CDNs) at Deliveroo HAProxy with Kubernetes for User-facing Traffic at SoundCloud Bandaid: Service Proxy at Dropbox CDN in LIVE's Encoder Layer at LINE Service Workers at Slack CDN Services at Spotify 分布式锁 Chubby: Lock Service for Loosely Coupled Distributed Systems at Google Distributed Locking at Uber Distributed Locks using Redis at GoSquared ZooKeeper at Twitter Eliminating Duplicate Queries using Distributed Locking at Chartio 分布式跟踪，追踪，测量 Zipkin: Distributed Systems Tracing at Twitter Improve Zipkin Traces using Kubernetes Pod Metadata at SoundCloud Canopy: Scalable Distributed Tracing \u0026amp; Analysis at Facebook Pintrace: Distributed Tracing at Pinterest XCMetrics: All-in-One Tool for Tracking Xcode Build Metrics at Spotify Real-time Distributed Tracing at LinkedIn Tracking Service Infrastructure at Scale at Shopify Distributed Tracing at HelloFresh Analyzing Distributed Trace Data at Pinterest Distributed Tracing at Uber JVM Profiler: Tracing Distributed JVM Applications at Uber Data Checking at Dropbox Tracing Distributed Systems at Showmax osquery Across the Enterprise at Palantir StatsD at Etsy StatsD at DoorDash 分布式调度 Distributed Task Scheduling (3 parts) at PagerDuty Building Cron at Google Distributed Cron Architecture at Quora Chronos: A Replacement for Cron at Airbnb Scheduler at Nextdoor Peloton: Unified Resource Scheduler for Diverse Cluster Workloads at Uber Fenzo: OSS Scheduler for Apache Mesos Frameworks at Netflix Airflow - Workflow Orchestration Airflow at Airbnb Airflow at Pandora Airflow at Robinhood Airflow at Lyft Airflow at Drivy Airflow at Grab Airflow at Adobe Auditing Airflow Job Runs at Walmart MaaT: DAG-based Distributed Task Scheduler at Alibaba boundary-layer: Declarative Airflow Workflows at Etsy 分布式监控和警告 Unicorn: Remediation System at eBay M3: Metrics and Monitoring Platform at Uber Athena: Automated Build Health Management System at Dropbox Vortex: Monitoring Server Applications at Dropbox Nuage: Cloud Management Service at LinkedIn Telltale: Application Monitoring at Netflix ThirdEye: Monitoring Platform at LinkedIn Periskop: Exception Monitoring Service at SoundCloud Securitybot: Distributed Alerting Bot at Dropbox Monitoring System at Alibaba Real User Monitoring at Dailymotion Alerting Ecosystem at Uber Alerting Framework at Airbnb Alerting on Service-Level Objectives (SLOs) at SoundCloud Job-based Forecasting Workflow for Observability Anomaly Detection at Uber Monitoring and Alert System using Graphite and Cabot at HackerEarth Observability (2 parts) at Twitter Distributed Security Alerting at Slack Real-Time News Alerting at Bloomberg Data Pipeline Monitoring System at LinkedIn Monitoring and Observability at Picnic 分布式安全 Approach to Security at Scale at Dropbox Aardvark and Repokid: AWS Least Privilege for Distributed, High-Velocity Development at Netflix LISA: Distributed Firewall at LinkedIn Secure Infrastructure To Store Bitcoin In The Cloud at Coinbase BinaryAlert: Real-time Serverless Malware Detection at Airbnb Scalable IAM Architecture to Secure Access to 100 AWS Accounts at Segment OAuth Audit Toolbox at Indeed Active Directory Password Blacklisting at Yelp Syscall Auditing at Scale at Slack Athenz: Fine-Grained, Role-Based Access Control at Yahoo WebAuthn Support for Secure Sign In at Dropbox Security Development Lifecycle at Slack Unprivileged Container Builds at Kinvolk Diffy: Differencing Engine for Digital Forensics in the Cloud at Netflix Detecting Credential Compromise in AWS at Netflix Scalable User Privacy at Spotify AVA: Audit Web Applications at Indeed TTL as a Service: Automatic Revocation of Stale Privileges at Yelp Enterprise Key Management at Slack Scalability and Authentication at Twitch 分布式消息，队列，事件流 Cape: Event Stream Processing Framework at Dropbox Brooklin: Distributed Service for Near Real-Time Data Streaming at LinkedIn Samza: Stream Processing System for Latency Insighs at LinkedIn Bullet: Forward-Looking Query Engine for Streaming Data at Yahoo EventHorizon: Tool for Watching Events Streaming at Etsy Qmessage: Distributed, Asynchronous Task Queue at Quora Cherami: Message Queue System for Transporting Async Tasks at Uber Dynein: Distributed Delayed Job Queueing System at Airbnb Messaging Service at Riot Games Debugging Production with Event Logging at Zillow Cross-platform In-app Messaging Orchestration Service at Netflix Video Gatekeeper at Netflix Scaling Push Messaging for Millions of Devices at Netflix Delaying Asynchronous Message Processing with RabbitMQ at Indeed Benchmarking Streaming Computation Engines at Yahoo Improving Stream Data Quality With Protobuf Schema Validation at Deliveroo Scaling Email Infrastructure at Medium Event Stream Database at Nike Event-Driven Messaging Domain-Driven Design at Alibaba Domain-Driven Design at Weebly Domain-Driven Design at Moonpig Scaling Event Sourcing for Netflix Downloads Scaling Event-Sourcing at Jet.com Event Sourcing (2 parts) at eBay Event Sourcing at FREE NOW Scalable content feed using Event Sourcing and CQRS patterns at Brainly Pub-Sub Messaging Pulsar: Pub-Sub Messaging at Scale at Yahoo Wormhole: Pub-Sub System at Facebook Pub-Sub in Chatting Architecture at LINE Pub-Sub in Microservices at Netflix Kafka - Message Broker Kafka at LinkedIn Kafka at Pinterest Kafka at Trello Kafka at Salesforce Kafka at The New York Times Kafka at Yelp Kafka at Criteo Kafka on Kubernetes at Shopify Migrating Kafka's Zookeeper with No Downtime at Yelp Reprocessing and Dead Letter Queues with Kafka at Uber Chaperone: Audit Kafka End-to-End at Uber Finding Kafka throughput limit in infrastructure at Dropbox Cost Orchestration at Walmart InfluxDB and Kafka to Scale to Over 1 Million Metrics a Second at Hulu Stream Data Deduplication Exactly-once Semantics with Kafka Real-time Deduping at Tapjoy Deduplication at Segment Deduplication at Mail.Ru Petabyte Scale Data Deduplication at Mixpanel 分布式日志 Logging at LinkedIn Scalable and Reliable Log Ingestion at Pinterest High-performance Replicated Log Service at Twitter Logging Service with Spark at CERN Accelerator Logging and Aggregation at Quora Collection and Analysis of Daemon Logs at Badoo Log Parsing with Static Code Analysis at Palantir Centralized Application Logging at eBay Enrich VPC Flow Logs at Hyper Scale to provide Network Insight at Netflix BookKeeper: Distributed Log Storage at Yahoo LogDevice: Distributed Data Store for Logs at Facebook LogFeeder: Log Collection System at Yelp DBLog: Generic Change-Data-Capture Framework at Netflix 分布式搜索 Search Architecture at Instagram Search Architecture at eBay Search Architecture at Box Search Discovery Indexing Platform at Coupang Universal Search System at Pinterest Improving Search Engine Efficiency by over 25% at eBay Indexing and Querying Telemetry Logs with Lucene at Palantir Query Understanding at TripAdvisor Search Federation Architecture at LinkedIn (2018) Search at Slack Search and Recommendations at DoorDash Search Service at Twitter (2014) Autocomplete Search (2 parts) at Traveloka Data-Driven Autocorrection System at Canva Adapting Search to Indian Phonetics at Flipkart Nautilus: Search Engine at Dropbox Galene: Search Architecture of LinkedIn Manas: High Performing Customized Search System at Pinterest Sherlock: Near Real Time Search Indexing at Flipkart Nebula: Storage Platform to Build Search Backends at Airbnb ELK (Elasticsearch, Logstash, Kibana) Stack Predictions in Real Time with ELK at Uber Building a scalable ELK stack at Envato ELK at Robinhood Scaling Elasticsearch Clusters at Uber Elasticsearch Performance Tuning Practice at eBay Improve Performance using Elasticsearch Plugins (2 parts) at Tinder Elasticsearch at Kickstarter Elasticsearch at Target Log Parsing with Logstash and Google Protocol Buffers at Trivago Fast Order Search using Data Pipeline and Elasticsearch at Yelp Moving Core Business Search to Elasticsearch at Yelp Sharding out Elasticsearch at Vinted Self-Ranking Search with Elasticsearch at Wattpad Vulcanizer: a library for operating Elasticsearch at Github 分布式存储 In-memory Storage MemSQL Architecture - The Fast (MVCC, InMem, LockFree, CodeGen) And Familiar (SQL) Optimizing Memcached Efficiency at Quora Real-Time Data Warehouse with MemSQL on Cisco UCS Moving to MemSQL at Tapjoy MemSQL and Kinesis for Real-time Insights at Disney MemSQL to Query Hundreds of Billions of Rows in a Dashboard at Pandora Object Storage Scaling HDFS at Uber Reasons for Choosing S3 over HDFS at Databricks File System on Amazon S3 at Quantcast Image Recovery at Scale Using S3 Versioning at Trivago Cloud Object Store at Yahoo Ambry: Distributed Immutable Object Store at LinkedIn Dynamometer: Scale Testing HDFS on Minimal Hardware with Maximum Fidelity at LinkedIn Hammerspace: Persistent, Concurrent, Off-heap Storage at Airbnb MezzFS: Mounting Object Storage in Media Processing Platform at Netflix Magic Pocket: In-house Multi-exabyte Storage System at Dropbox 关系数据库 MySQL for Schema-less Data at FriendFeed MySQL at Pinterest PostgreSQL at Twitch Scaling MySQL-based Financial Reporting System at Airbnb Scaling MySQL at Wix MaxScale (MySQL) Database Proxy at Airbnb Switching from Postgres to MySQL at Uber Handling Growth with Postgres at Instagram Scaling the Analytics Database (Postgres) at TransferWise Updating a 50 Terabyte PostgreSQL Database at Adyen Scaling Database Access for 100s of Billions of Queries per Day at PayPal Minimizing Read-Write MySQL Downtime at Yelp Replication MySQL Parallel Replication (4 parts) at Booking.com Mitigating MySQL Replication Lag and Reducing Read Load at Github Black-Box Auditing: Verifying End-to-End Replication Integrity between MySQL and Redshift at Yelp Partitioning Main MySQL Database at Airbnb Herb: Multi-DC Replication Engine for Schemaless Datastore at Uber Sharding Sharding MySQL at Pinterest Sharding MySQL at Twilio Sharding MySQL at Square Sharding MySQL at Quora Sharding Layer of Schemaless Datastore at Uber Sharding \u0026amp; IDs at Instagram Solr: Improving Performance for Batch Indexing at Box Geosharded Recommendations (3 parts) at Tinder Scaling Services with Shard Manager at Facebook Presto the Distributed SQL Query Engine Presto at Pinterest Presto Infrastructure at Lyft Presto at Grab Engineering Data Analytics with Presto and Apache Parquet at Uber Data Wrangling at Slack Presto in Big Data Platform on AWS at Netflix Presto Auto Scaling at Eventbrite NoSQL 数据库 Key-Value Databases DynamoDB at Nike DynamoDB at Segment DynamoDB at Mapbox Manhattan: Distributed Key-Value Database at Twitter Sherpa: Distributed NoSQL Key-Value Store at Yahoo HaloDB: Embedded Key-Value Storage Engine at Yahoo MPH: Fast and Compact Immutable Key-Value Stores at Indeed Venice: Distributed Key-Value Database at Linkedin Columnar Databases Cassandra Cassandra at Instagram Storing Images in Cassandra at Walmart Storing Messages with Cassandra at Discord Scaling Cassandra Cluster at Walmart Scaling Ad Analytics with Cassandra at Yelp Scaling to 100+ Million Reads/Writes using Spark and Cassandra at Dream11 Moving Food Feed from Redis to Cassandra at Zomato Benchmarking Cassandra Scalability on AWS at Netflix Service Decomposition at Scale with Cassandra at Intuit QuickBooks Cassandra for Keeping Counts In Sync at SoundCloud cstar: Cassandra Orchestration Tool at Spotify HBase HBase at Salesforce HBase in Facebook Messages HBase in Imgur Notification Improving HBase Backup Efficiency at Pinterest HBase at Xiaomi Redshift Redshift at GIPHY Redshift at Hudl Redshift at Drivy Document Databases eBay: Building Mission-Critical Multi-Data Center Applications with MongoDB MongoDB at Baidu: Multi-Tenant Cluster Storing 200+ Billion Documents across 160 Shards Migrating Mongo Data at Addepar The AWS and MongoDB Infrastructure of Parse (acquired by Facebook) Migrating Mountains of Mongo Data at Addepar Couchbase Ecosystem at LinkedIn SimpleDB at Zendesk Espresso: Distributed Document Store at LinkedIn Graph Databases FlockDB: Distributed Graph Database at Twitter TAO: Distributed Data Store for the Social Graph at Facebook Akutan: Distributed Knowledge Graph Store at eBay 时间序列数据库 Beringei: High-performance Time Series Storage Engine at Facebook MetricsDB: TimeSeries Database for storing metrics at Twitter Atlas: In-memory Dimensional Time Series Database at Netflix Heroic: Time Series Database at Spotify Roshi: Distributed Storage System for Time-Series Event at SoundCloud Goku: Time Series Database at Pinterest Scaling Time Series Data Storage (2 parts) at Netflix Druid - Real-time Analytics Database Druid at Airbnb Druid at Walmart Druid at eBay Druid at Netflix 分布式存储库、依赖性和配置管理 DGit: Distributed Git at Github Stemma: Distributed Git Server at Palantir Configuration Management for Distributed Systems at Flickr Git Repository at Microsoft Solve Git Problem with Large Repositories at Microsoft Single Repository at Google Scaling Infrastructure and (Git) Workflow at Adyen Dotfiles Distribution at Booking.com Secret Detector: Preventing Secrets in Source Code at Yelp Managing Software Dependency at Scale at LinkedIn Merging Code in High-velocity Repositories at LinkedIn Dynamic Configuration at Twitter Dynamic Configuration at Mixpanel Dynamic Configuration at GoDaddy 扩展持续集成和持续交付 Continuous Integration Stack at Facebook Continuous Integration with Distributed Repositories and Dependencies at Netflix Continuous Integration and Deployment with Bazel at Dropbox Continuous Deployments at BuzzFeed Screwdriver: Continuous Delivery Build System for Dynamic Infrastructure at Yahoo CI/CD at Betterment CI/CD at Brainly Scaling iOS CI with Anka at Shopify Scaling Jira Server at Yelp Auto-scaling CI/CD cluster at Flexport 可用性 Resilience Engineering: Learning to Embrace Failure Resilience Engineering with Project Waterbear at LinkedIn Resiliency against Traffic Oversaturation at iHeartRadio Resiliency in Distributed Systems at GO-JEK Practical NoSQL Resilience Design Pattern for the Enterprise at eBay Ensuring Resilience to Disaster at Quora Site Resiliency at Expedia Resiliency and Disaster Recovery with Kafka at eBay Disaster Recovery for Multi-Region Kafka at Uber Failover The Evolution of Global Traffic Routing and Failover Testing for Disaster Recovery Failover Testing Designing a Microservices Architecture for Failure ELB for Automatic Failover at GoSquared Eliminate the Database for Higher Availability at American Express Failover with Redis Sentinel at Vinted High-availability SaaS Infrastructure at FreeAgent MySQL High Availability at GitHub Business Continuity \u0026amp; Disaster Recovery at Walmart Load Balancing Introduction to Modern Network Load Balancing and Proxying Top Five (Load Balancing) Scalability Patterns Load Balancing infrastructure to support more than 1.3 billion users at Facebook DHCPLB: DHCP Load Balancer at Facebook Katran: Scalable Network Load Balancer at Facebook Deterministic Aperture: A Distributed, Load Balancing Algorithm at Twitter Load Balancing with Eureka at Netflix Edge Load Balancing at Netflix Zuul 2: Cloud Gateway at Netflix Load Balancing at Yelp Load Balancing at Github Consistent Hashing to Improve Load Balancing at Vimeo UDP Load Balancing at 500 pixel QALM: QoS Load Management Framework at Uber Traffic Steering using Rum DNS at LinkedIn Traffic Infrastructure (Edge Network) at Dropbox Intelligent DNS based load balancing at Dropbox Monitor DNS systems at Stripe Multi-DNS Architecture (3 parts) at Monday Rate Limiting Rate Limiting for Scaling to Millions of Domains at Cloudflare Cloud Bouncer: Distributed Rate Limiting at Yahoo Scaling API with Rate Limiters at Stripe Distributed Rate Limiting at Allegro Ratequeue: Core Queueing-And-Rate-Limiting System at Twilio Quotas Service at Grab Autoscaling Autoscaling Pinterest Autoscaling Based on Request Queuing at Square Autoscaling Jenkins at Trivago Autoscaling Pub-Sub Consumers at Spotify Autoscaling Bigtable Clusters based on CPU Load at Spotify Autoscaling AWS Step Functions Activities at Yelp Scryer: Predictive Auto Scaling Engine at Netflix Bouncer: Simple AWS Auto Scaling Rollovers at Palantir Clusterman: Autoscaling Mesos Clusters at Yelp Availability in Globally Distributed Storage Systems at Google NodeJS High Availability at Yahoo Operations (11 parts) at LinkedIn Monitoring Powers High Availability for LinkedIn Feed Supporting Global Events at Facebook High Availability at BlaBlaCar High Availability at Netflix High Availability Cloud Infrastructure at Twilio Automating Datacenter Operations at Dropbox Globalizing Player Accounts at Riot Games 稳定性 Circuit Breaker Circuit Breaking in Distributed Systems Circuit Breakers for Distributed Services at LINE Applying Circuit Breaker to Channel Gateway at LINE Lessons in Resilience at SoundCloud Circuit Breaker for Scaling Containers Protector: Circuit Breaker for Time Series Databases at Trivago Improved Production Stability with Circuit Breakers at Heroku Circuit Breakers at Zendesk Circuit Breakers at Traveloka Timeouts Fault Tolerance (Timeouts and Retries, Thread Separation, Semaphores, Circuit Breakers) at Neflix Enforce Timeout: A Reliability Methodology at DoorDash Troubleshooting a Connection Timeout Issue with tcp_tw_recycle Enabled at eBay Crash-safe Replication for MySQL at Booking.com Bulkheads: Partition and Tolerate Failure in One Part Steady State: Always Put Logs on Separate Disk Throttling: Maintain a Steady Pace Multi-Clustering: Improving Resiliency and Stability of a Large-scale Monolithic API Service at LinkedIn Determinism (4 parts) in League of Legends Server 性能 Performance Optimization on OS, Storage, Database, Network Improving Performance with Background Data Prefetching at Instagram Compression Techniques to Solve Network I/O Bottlenecks at eBay Optimizing Web Servers for High Throughput and Low Latency at Dropbox Linux Performance Analysis in 60.000 Milliseconds at Netflix Live Downsizing Google Cloud Persistent Disks (PD-SSD) at Mixpanel Decreasing RAM Usage by 40% Using jemalloc with Python \u0026amp; Celery at Zapier Reducing Memory Footprint at Slack Performance Improvements at Pinterest Server Side Rendering at Wix 30x Performance Improvements on MySQLStreamer at Yelp Optimizing APIs at Netflix Performance Monitoring with Riemann and Clojure at Walmart Performance Tracking Dashboard for Live Games at Zynga Optimizing CAL Report Hadoop MapReduce Jobs at eBay Performance Tuning on Quartz Scheduler at eBay Profiling C++ (Part 1: Optimization, Part 2: Measurement and Analysis) at Riot Games Profiling React Server-Side Rendering at HomeAway Hardware-Assisted Video Transcoding at Dailymotion Cross Shard Transactions at 10 Million RPS at Dropbox API Profiling at Pinterest Pagelets Parallelize Server-side Processing at Yelp Improving key expiration in Redis at Twitter Ad Delivery Network Performance Optimization with Flame Graphs at MindGeek Predictive CPU isolation of containers at Netflix Cloud Jewels: Estimating kWh in the Cloud at Etsy Unthrottled: Fixing CPU Limits in the Cloud (2 parts) at Indeed Performance Optimization by Tuning Garbage Collection Garbage Collection in Java Applications at LinkedIn Garbage Collection in High-Throughput, Low-Latency Machine Learning Services at Adobe Garbage Collection in Redux Applications at SoundCloud Garbage Collection in Go Application at Twitch Analyzing V8 Garbage Collection Logs at Alibaba Python Garbage Collection for Dropping 50% Memory Growth Per Request at Instagram Performance Impact of Removing Out of Band Garbage Collector (OOBGC) at Github Debugging Java Memory Leaks at Allegro Optimizing JVM at Alibaba Tuning JVM Memory for Large-scale Services at Uber Performance Optimization on Image, Video, Page Load Optimizing 360 Photos at Scale at Facebook Reducing Image File Size in the Photos Infrastructure at Etsy Improving GIF Performance at Pinterest Optimizing Video Playback Performance at Pinterest Optimizing Video Stream for Low Bandwidth with Dynamic Optimizer at Netflix Adaptive Video Streaming at YouTube Reducing Video Loading Time at Dailymotion Improving Homepage Performance at Zillow The Process of Optimizing for Client Performance at Expedia Web Performance at BBC Performance Optimization by Brotli Compression Boosting Site Speed Using Brotli Compression at LinkedIn Brotli at Booking.com Brotli at Treebo Deploying Brotli for Static Content at Dropbox Progressive Enhancement with Brotli at Yelp Speeding Up Redis with Compression at Doordash Performance Optimization on Languages and Frameworks Python at Netflix Python at scale (3 parts) at Instagram PHP at Slack Go at Trivago Ruby on Rails at GitLab Choosing a Language Stack at WeWork Switching from Go to Rust at Discord ASP.NET Core Performance Optimization at Agoda 智能 大数据 Uber的数据平台 宝马的数据平台 Netflix的数据平台 Flipkart的数据平台 Coupang的数据平台 DoorDash的数据平台 Khan Academy数据平台 Airbnb的数据基础设施 LinkedIn的数据基础设施 GO-JEK的数据基础设施 Pinterest的数据挖掘基础设施 Pinterest的数据分析架构 Spotify的大数据处理(2部分) Uber的大数据处理 Lyft的分析管道 Grammarly的分析管道 Teads的分析管道 用于PayPal的实时欺诈防范的机器学习数据管道 LinkedIn的大数据分析和机器学习技术 LinkedIn的Hadoop自助报告平台 LinkedIn的隐私保护分析与报告 用于跟踪沃尔玛商品供应情况的分析平台 HALO：Facebook的硬件分析和生命周期优化 RBEA：King的实时分析平台 AresDB：Uber的GPU驱动实时分析引擎 AthenaX：Uber的流媒体分析平台 Delta: Netflix的数据同步和增强平台 Keystone.Netflix的实时流处理平台 Databook: 在Uber用元数据将大数据转化为知识 Amundsen：Lyft的数据发现和元数据引擎 Maze：Uber的漏斗可视化平台 Metacat: 让大数据在Netflix变得可发现和有意义 SpinalTap：Airbnb的变化数据采集系统 Accelerator: eBay的快速数据处理框架 Omid: 雅虎交易处理平台 TensorFlowOnSpark: 在雅虎大数据集群上进行分布式深度学习 Spark on Scala: Adobe公司的分析参考架构 在Spotify的实验平台（2部分） Airbnb的实验平台 Zalando的智能产品平台 LINE公司的日志分析平台 Myntra的数据可视化平台 在Netflix构建和扩展数据 为Pinterest的计算机视觉任务构建一个可扩展的数据管理系统 Etsy的结构化数据 拓展成熟的数据管道--Airbnb的管理开销 Airbnb的Spark分区策略 Distributed Machine Learning Aroma: Using ML for Code Recommendation at Facebook Flyte: Cloud Native Machine Learning and Data Processing Platform at Lyft Michelangelo: Machine Learning Platform at Uber Scaling Michelangelo Machine Learning Platform at Yelp Horovod: Open Source Distributed Deep Learning Framework for TensorFlow at Uber COTA: Improving Customer Care with NLP \u0026amp; Machine Learning at Uber Manifold: Model-Agnostic Visual Debugging Tool for Machine Learning at Uber Repo-Topix: Topic Extraction Framework at Github Concourse: Generating Personalized Content Notifications in Near-Real-Time at LinkedIn Altus Care: Applying a Chatbot to Platform Engineering at eBay PyKrylov: Accelerating Machine Learning Research at eBay Box Graph: Spontaneous Social Network at Box PricingNet: Pricing Modelling with Neural Networks at Skyscanner PinText: Multitask Text Embedding System at Pinterest Cannes: ML saves $1.7M a year on document previews at Dropbox Scaling Gradient Boosted Trees for Click-Through-Rate Prediction at Yelp Learning with Privacy at Scale at Apple Deep Learning for Image Classification Experiment at Mercari Deep Learning for Frame Detection in Product Images at Allegro Content-based Video Relevance Prediction at Hulu Improving Photo Selection With Deep Learning at TripAdvisor Personalized Recommendations for Experiences Using Deep Learning at TripAdvisor Personalised Recommender Systems at BBC Machine Learning (2 parts) at Condé Nast Natural Language Processing and Content Analysis (2 parts) at Condé Nast Mapping the World of Music Using Machine Learning (2 parts) at iHeartRadio Machine Learning to Improve Streaming Quality at Netflix Machine Learning to Match Drivers \u0026amp; Riders at GO-JEK Improving Video Thumbnails with Deep Neural Nets at YouTube Quantile Regression for Delivering On Time at Instacart Cross-Lingual End-to-End Product Search with Deep Learning at Zalando Machine Learning at Jane Street Machine Learning for Ranking Answers End-to-End at Quora Clustering Similar Stories Using LDA at Flipboard Similarity Search at Flickr Large-Scale Machine Learning Pipeline for Job Recommendations at Indeed Deep Learning from Prototype to Production at Taboola Atom Smashing using Machine Learning at CERN Mapping Tags at Medium Clustering with the Dirichlet Process Mixture Model in Scala at Monsanto Map Pins with DBSCAN \u0026amp; Random Forests at Foursquare Detecting and Preventing Fraud at Uber Forecasting at Uber Financial Forecasting at Uber Productionizing ML with Workflows at Twitter GUI Testing Powered by Deep Learning at eBay Scaling Machine Learning to Recommend Driving Routes at Pivotal Real-Time Predictions at DoorDash Machine Intelligence at Dropbox Machine Learning for Indexing Text from Billions of Images at Dropbox Modeling User Journeys via Semantic Embeddings at Etsy Automated Fake Account Detection at LinkedIn Building Knowledge Graph at Airbnb Core Modeling at Instagram Neural Architecture Search (NAS) for Prohibited Item Detection at Mercari Computer Vision at Airbnb 3D Home Backend Algorithms at Zillow Long-term Forecasts at Lyft Discovering Popular Dishes with Deep Learning at Yelp SplitNet Architecture for Ad Candidate Ranking at Twitter Jobs Filter at Indeed Architecting Restaurant Wait Time Predictions at Yelp Music Personalization at Spotify Deep Learning for Domain Name Valuation at GoDaddy Similarity Clustering to Catch Fraud Rings at Stripe Personalized Search at Etsy ML Feature Serving Infrastructure at Lyft 架构 Systems We Make Tech Stack (2 parts) at Uber Tech Stack at Medium Tech Stack at Shopify Building Services (4 parts) at Airbnb Architecture of Evernote Architecture of Chat Service (3 parts) at Riot Games Architecture of League of Legends Client Update Architecture of Ad Platform at Twitter Basic Architecture of Slack Back-end at LinkedIn Back-end at Flickr Infrastructure (3 parts) at Zendesk Cloud Infrastructure at Grubhub Real-time Presence Platform at LinkedIn Settings Platform at LinkedIn Nearline System for Scale and Performance (2 parts) at Glassdoor Real-time User Action Counting System for Ads at Pinterest API Platform at Riot Games Games Platform at The New York Times Kabootar: Communication Platform at Swiggy Simone: Distributed Simulation Service at Netflix Seagull: Distributed System that Helps Running \u0026gt; 20 Million Tests Per Day at Yelp PriceAggregator: Intelligent System for Hotel Price Fetching (3 parts) at Agoda Phoenix: Testing Platform (3 parts) at Tinder Hexagonal Architecture at Netflix Architecture of Play API Service at Netflix Architecture of Sticker Services at LINE Stack Overflow Enterprise at Palantir Architecture of Following Feed, Interest Feed, and Picked For You at Pinterest API Specification Workflow at WeWork Media Database at Netflix Member Transaction History Architecture at Walmart Sync Engine (2 parts) at Dropbox Architectures of Finance and Banking Systems Bank Backend at Monzo Trading Platform for Scale at Wealthsimple Core Banking System at Margo Bank Architecture of Nubank Tech Stack at TransferWise Tech Stack at Addepar Avoiding Double Payments in a Distributed Payments System at Airbnb 面试 Designing Large-Scale Systems My Scaling Hero - Jeff Atwood (a dose of Endorphins before your interview, JK) Software Engineering Advice from Building Large-Scale Distributed Systems - Jeff Dean Introduction to Architecting Systems for Scale Anatomy of a System Design Interview 8 Things You Need to Know Before a System Design Interview Top 10 System Design Interview Questions Top 10 Common Large-Scale Software Architectural Patterns in a Nutshell Cloud Big Data Design Patterns - Lynn Langit How NOT to design Netflix in your 45-minute System Design Interview? API Best Practices: Webhooks, Deprecation, and Design Explaining Low-Level Systems (OS, Network/Protocol, Database, Storage) OSI and TCP/IP Cheat Sheet The Precise Meaning of I/O Wait Time in Linux Paxos Made Live – An Engineering Perspective How to do Distributed Locking SQL Transaction Isolation Levels Explained \u0026quot;What Happens When... and How\u0026quot; Questions Netflix: What Happens When You Press Play? Monzo: How Peer-To-Peer Payments Work Transit and Peering: How Your Requests Reach GitHub How Spotify Streams Music 组织 Engineering Levels at SoundCloud Engineering Roles at Palantir Scaling Engineering Teams at Twitter Scaling Decision-Making Across Teams at LinkedIn Scaling Data Science Team at GOJEK Scaling Agile at Zalando Scaling Agile at bol.com Lessons Learned from Scaling a Product Team at Intercom Hiring, Managing, and Scaling Engineering Teams at Typeform Scaling the Datagram Team at Instagram Scaling the Design Team at Flexport Team Model for Scaling a Design System at Salesforce Building Analytics Team (4 parts) at Wish From 2 Founders to 1000 Employees at Transferwise Lessons Learned Growing a UX Team from 10 to 170 at Adobe Five Lessons from Scaling at Pinterest Approach Engineering at Vinted Using Metrics to Improve the Development Process (and Coach People) at Indeed Mistakes to Avoid while Creating an Internal Product at Skyscanner RACI (Responsible, Accountable, Consulted, Informed) at Etsy Four Pillars of Leading People (Empathy, Inspiration, Trust, Honesty) at Zalando Pair Programming at Shopify Distributed Responsibility at Asana Rotating Engineers at Zalando Experiment Idea Review at Pinterest Tech Migrations at Spotify Improving Code Ownership at Yelp Agile Code Base at eBay Code Review Code Review at Palantir Code Review at LINE Code Reviews at Medium Code Review at LinkedIn Code Review at Disney Code Review at Netlify 访谈 Distributed Systems in One Lesson - Tim Berglund, Senior Director of Developer Experience at Confluent Building Real Time Infrastructure at Facebook - Jeff Barber and Shie Erlich, Software Engineer at Facebook Building Reliable Social Infrastructure for Google - Marc Alvidrez, Senior Manager at Google Building a Distributed Build System at Google Scale - Aysylu Greenberg, SDE at Google Site Reliability Engineering at Dropbox - Tammy Butow, Site Reliability Engineering Manager at Dropbox How Google Does Planet-Scale for Planet-Scale Infra - Melissa Binde, SRE Director for Google Cloud Platform Netflix Guide to Microservices - Josh Evans, Director of Operations Engineering at Netflix Achieving Rapid Response Times in Large Online Services - Jeff Dean, Google Senior Fellow Architecture to Handle 80K RPS Celebrity Sales at Shopify - Simon Eskildsen, Engineering Lead at Shopify Lessons of Scale at Facebook - Bobby Johnson, Director of Engineering at Facebook Performance Optimization for the Greater China Region at Salesforce - Jeff Cheng, Enterprise Architect at Salesforce How GIPHY Delivers a GIF to 300 Millions Users - Alex Hoang and Nima Khoshini, Services Engineers at GIPHY High Performance Packet Processing Platform at Alibaba - Haiyong Wang, Senior Director at Alibaba Solving Large-scale Data Center and Cloud Interconnection Problems - Ihab Tarazi, CTO at Equinix Scaling Dropbox - Kevin Modzelewski, Back-end Engineer at Dropbox Scaling Reliability at Dropbox - Sat Kriya Khalsa, SRE at Dropbox Scaling with Performance at Facebook - Bill Jia, VP of Infrastructure at Facebook Scaling Live Videos to a Billion Users at Facebook - Sachin Kulkarni, Director of Engineering at Facebook Scaling Infrastructure at Instagram - Lisa Guo, Instagram Engineering Scaling Infrastructure at Twitter - Yao Yue, Staff Software Engineer at Twitter Scaling Infrastructure at Etsy - Bethany Macri, Engineering Manager at Etsy Scaling Real-time Infrastructure at Alibaba for Global Shopping Holiday - Xiaowei Jiang, Senior Director at Alibaba Scaling Data Infrastructure at Spotify - Matti (Lepistö) Pehrs, Spotify Scaling Pinterest - Marty Weiner, Pinterest’s founding engineer Scaling Slack - Bing Wei, Software Engineer (Infrastructure) at Slack Scaling Backend at Youtube - Sugu Sougoumarane, SDE at Youtube Scaling Backend at Uber - Matt Ranney, Chief Systems Architect at Uber Scaling Global CDN at Netflix - Dave Temkin, Director of Global Networks at Netflix Scaling Load Balancing Infra to Support 1.3 Billion Users at Facebook - Patrick Shuff, Production Engineer at Facebook Scaling (a NSFW site) to 200 Million Views A Day And Beyond - Eric Pickup, Lead Platform Developer at MindGeek Scaling Counting Infrastructure at Quora - Chun-Ho Hung and Nikhil Gar, SEs at Quora Scaling Git at Microsoft - Saeed Noursalehi, Principal Program Manager at Microsoft Scaling Multitenant Architecture Across Multiple Data Centres at Shopify - Weingarten, Engineering Lead at Shopify 书籍 Big Data, Web Ops \u0026amp; DevOps Ebooks - O'Reilly (Online - Free) Google Site Reliability Engineering (Online - Free) Distributed Systems for Fun and Profit (Online - Free) What Every Developer Should Know About SQL Performance (Online - Free) Beyond the Twelve-Factor App - Exploring the DNA of Highly Scalable, Resilient Cloud Applications (Free) Chaos Engineering - Building Confidence in System Behavior through Experiments (Free) The Art of Scalability Web Scalability for Startup Engineers Scalability Rules: 50 Principles for Scaling Web Sites (全文完)\n","link":"https://huangbaihua.gitee.io/post/awesome-scalability/","section":"post","tags":["技术管理","系统架构","译文"],"title":"优秀的可伸缩性"},{"body":"如何设计大规模分布式系统已经成为软件工程师面试的标配。工程师们在系统设计面试中表现吃力，主要有两个原因：一、缺少开发大规模系统的经验；二、系统设计面试非机构化，开放性的特点，通常问题都没有标准答案。\n在系统设计面试中表现出色将给你带来高回报，因为它能反映你处理复杂系统的能力，并能转化成面试公司为你提供的高级职位和高薪水。\n本文列举了10大系统设计面试题，在这些面试题中，应该如何回答，跟面试官讨论的关键点应该在哪里。\n源文: Top 10 System Design Interview Questions for Software Engineers (Fahim ul Haq)\n1、设计一个短地址服务 给定一个典型的长地址(URL)，如何设计服务生成一个短地址并保证它的唯一\n做如下讨论:\n如何为每个URL生成一个唯一的ID? 如何大规模地生成唯一的ID（每秒都有成千上万的URL短地址请求）? 如何处理重定向? 如何支持自定义短网址? 如何删除过期的URL等? 如何跟踪点击统计? 2、设计面向全球用户的视频流媒体服务 一想到视频，意味着你的服务将储存和传输PB级的数据。 你要讨论的是如何有效的存储和分发数据，以便大量用户同时观看和分享视频。\n此外，还要讨论：\n如何记录视频的统计数据？如视频总浏览量，投票量等 如何给视频添加实时的评论（如弹幕） 3、设计面向全球用户的聊天服务 该服务面试官想知道的是：\n如何设计用户间的一对一的聊天？ 如何扩展你的设计来支持群聊？ 当用户断网如何处理？ 什么时候发送推送消息？ 你能否提供端到端的加密？如何做？ 4、设计社交网络，留言板服务 用户可以发布问题或分享链接。其他用户可以回答问题或对共享链接发表评论。\n记录每个回答的统计数据，例如总浏览量、投票数等 用户可以关注其他用户或主题 时间线将由所有用户的最新问题和他们关注的话题组成（类似于信息流生成） 5、设计面向全球用户的文件存储和分享服务 讨论点:\n用户如何上传/查看/搜索/共享文件或照片 如何跟踪文件共享的传输情况 如何允许多个用户编辑同一个文档 6、服务上亿用户的社交媒体服务 当设计一个拥有数亿（或数十亿）用户的社交媒体服务时，面试官很想知道你会如何设计以下组件:\n高效存储和搜索帖子或微博 信息流的生成 社交图谱（谁与谁成为好友或谁关注谁--特别是当数百万用户关注一个名人的时候 很多时候，面试官会用整个面试的时间来讨论信息流的设计 7、设计一个共享打车服务 在设计共享打车服务的时候，要讨论以下内容\n最核心的业务场景--当用户请求乘车时，如何有效地将他们与附近的司机匹配 如何为总是在移动的司机和乘车人存储数百万个地理位置 如何处理司机/骑手位置的更新（每秒更新数百万次） 8、设计搜索引擎相关服务 对于Type-Ahead，当用户输入查询时，你需要设计一个服务，它将根据用户输入的关键字推荐前10个搜索词。讨论的内容包括：\n如何存储以前的搜索查询 如何保持返回的数据总是新的 如何为已经输入的字符串找到最佳匹配 如何处理更新和用户输入太快的情况 对于网络爬虫来说，我们必须设计一个可扩展的服务，它可以抓取整个Web，并且可以获取数以亿计的Web文档。讨论的内容包括：\n如何找到新的网页 如何对动态变化的网页进行优先级排序 如何确保你的爬虫不会无限地停留在同一个域名上 9、设计一个API速率限制器 开发一个速率限制器服务\n限制一个实体在一个时间窗口内可以向一个API发送的请求数量，例如，每秒15个请求 速率限制应该适用于分布式设置，因为API是通过服务器集群访问的 你将如何处理流量调节 10、设计一个查找附近的人或地点的服务 这项服务将需要为数百万人/地点存储位置。讨论的内容包括\n该服务的用户如何能够搜索附近的朋友或地点 如何对地方进行排名（根据距离、用户评价） 如何根据人口密度有效地存储位置数据（例如，纽约市的一个街区可能比一个小城市的人都多） (全文完)\n","link":"https://huangbaihua.gitee.io/post/top-10-sdis/","section":"post","tags":["系统架构","译文"],"title":"10大系统设计面试题"},{"body":"高效的程序员应该具备哪些素质，\u0026quot;10倍程序员\u0026quot;给你答案!。\n源文: The mythical 10x programmer (antirez)\n在编程世界中，10倍程序员是指那些能够完成普通程序员十倍工作的程序员，对于普通程序员， 我们可以想象他是一个擅长一般编码工作，但并不具备10倍程序员这样具有神奇魔力的程序员。 其实为了更好地描述 \u0026quot;普通程序员 \u0026quot; 的特点，不如说它代表的是程序员这个群体中，拥有平均编程产出的人。\n编程界对于是否存在这样的程序员观点明显两级分化： 一方说压根就不存在这样的10倍程序员，另一方又说它不仅存在， 只要你知道去哪里找，甚至还有100倍程序员存在。\n如果你把编程看成是一门 \u0026quot;线性\u0026quot;学科，那么很显然，10倍程序员看起来是不太合理的。一个人跑步怎么可能比另一个人跑得快10倍？ 又或者一个建筑工人在同样的时间内能建造出另一个工人10倍的东西？ 然而编程是一门设计学科，它非常特殊。 即使程序员不参与程序的实际架构设计，实现程序的功能仍然需要进行精心地设计。\n所以，如果程序的设计和实现不是线性的能力，那么像经验、编码能力、基础知识、识别系统无用部分的能力，在我看来，不仅仅是线性的 优势，也是创建程序的效率倍增器。当然，这样的现象通常发生在那些即能设计又能实现程序的人身上。越是“目标导向”的任务，一个潜在的10倍 程序员越能发挥自己的能力，以较小的付出达成目标。当手头的任务越是固定，对使用什么工具以及如何实现有确定的指导方针时，10倍程序员 在更短时间内完成大量工作的能力就会被削弱，但他仍能可以利用“局部”设计的可能性更好地完成工作。\n在二十年的程序员生涯中，我观察了其它与我一起工作的程序员；也作为同事，在我的指导下，为了达成某个目标，为Redis和其它项目提供补丁。 他们当中很多人对我说，他们认为我是一个编程非常快的程序员。考虑到我还远不是一个工作狂，但我也会把自己做为一个如何快速编程的一个参考。\n以下是我认为对程序员工作效率影响最大的因素。\n赤裸裸的编程能力： 完成子任务的能力 程序员最明显的限制或优势之一，就是实际编码实现程序子任务的能力：如编写一个函数，一个算法或者其它什么。 令人惊讶的是，根据我的经验，非常有效地使用基本的命令式编程结构来实现某些功能的能力并不像人们想象的那样普遍。 在一个团队中，有时我发现一些理论非常差的程序员，他们甚至连一个简单的排序算法都不知道，却能比那些理论上非常优秀， 但在实现解决方案的实践中表现非常糟糕的刚毕业程序员能完成更多的工作。\n经验： 模式匹配 我所说的经验是指针对一些重复性任务已经探索出的一套解决方案。一个有经验的程序员最终会知道如何处理各种子任务。 这既避免了大量的设计工作，尤其经验是抵御设计错误的极其有力的武器，而设计错误又是简单性的最大敌人之一。\n专注力： 实际时间VS假设时间 如果不看时间质量，写代码的小时数是无关紧要的。缺乏专注力可以由内部和外部因素产生。 内部因素是拖延症，对手头的项目缺乏兴趣（你不可能做好你不喜欢的事情），缺乏运动、健康，睡眠不好或很少。 外部因素是频繁的会议、没有办公场所环境、同事经常打断等等。似乎自然而然，试图提高专注力，减少干扰，会对编程生产力产生非边际效应。 有时候为了获得专注力，需要采取极端的措施。比如我会不时地看看邮件，但是大部分邮件都不会回复。\n设计牺牲： 牺牲5%，得到90% 当人们不愿意认识到项目的一个非功能性目标带来非常大的设计复杂性，或者使另一个更重要的目标很难完成时，往往会产生复杂性， 因为在功能特性和非功能特性之间存在着设计矛盾。 对于一个设计师来说，认识到设计中所有不容易实现的部分是非常重要的，也就是说，付出和产出之间是不成正比的。 一个项目的执行是为了实现产出的最大化，要准确地关注那些重要的、可以在合理的时间内实现的方面。例如在设计Disque这个消息中间件时，在某个时刻我意识到， 只要为消息努力提供最佳的排序，项目的其他方面都可以得到实质性的改善：可用性、查询语言和客户端交互、简单性和性能。\n简单性 这是一个显而易见的观点，意味着所有和没有。为了理解什么是简单性，值得检查一下复杂性通常是如何产生的。我认为，产生复杂性的两个主要因素是： 一，不愿进行设计牺牲，二，设计活动中错误的积累。\n如果你在设计过程中思考，每追求一条错误的路径，我们就会离最优解越来越远。一个最初的设计错误，在错误的人手里，不会产生对同一系统的重新设计， 而是会导致设计另一个更复杂的解决方案，以应对最初的错误。因此，项目每错一步，就会变得更加复杂，效率降低。\n实现简单化的方法就是用 \u0026quot;概念验证 \u0026quot;来推理，让大量的简单设计在程序员的脑海中探索，从一些看起来最可行、最直接的方案开始工作。之后根据经验和个人的设计能力，可以改进设计， 为需要解决的子设计找到合理的解决方案。\n然而每次需要复杂的解决方案时，都要经过长时间的推理，如何避免复杂，只有在没有找到更好的可能性，甚至考虑完全不同的替代方案时，才会继续朝这个方向发展。\n完美主义,或者说如何扼杀你的生产力，让你的设计出现偏差。 完美主义有两种变体：一种是在程序中达到最佳的可衡量性能的工程文化，另一种是人格特质。在这两种情况下，我认为这是程序员快速交付程序的最大障碍之一。 完美主义和对外部评判的恐惧插入了一种设计偏见，会导致错误的选择，以便只根据心理或微不足道的可测量参数来完善设计，其中像鲁棒性、简单性、及时交付能力这样的东西，往往从不考虑。\n知识：一些理论会有帮助 在处理复杂的任务时，关于数据结构的知识、计算的基本限制、非琐碎的算法，这些都非常适用于某些任务的建模，都会对找到合适的设计产生影响。不需要成为一个什么都懂的超级专家， 但至少要知道一个问题的众多潜在解决方案，这当然是需要的。例如，可以将设计牺牲（接受一定的错误百分比）和了解概率集基数估计量组合在一起，以避免复杂，缓慢且内存效率低的解决方案， 以便对计算流中的唯一项进行计数。\n低层次： 理解机器 程序中的一些问题，即使是在使用高级语言的情况下，也是由于对计算机如何执行某项任务的误解而产生的。 这甚至可能导致由于所使用的工具或算法存在根本性的问题，需要重新设计和重新从头开始实施一个项目。 良好的C语言能力，对CPU工作原理的理解， 以及对内核如何运行和系统调用如何实现的清晰思路，可以避免后期出现不好的意外。\n调试技巧 为了找到bug，很容易花费巨大的工作量。善于循序渐进获取bug的错误状态，以便用一套合理的步骤来修复它，加上写简单代码的态度，不可能包含太多的bug， 这两者对程序员的效率有很大的影响。\n程序员的以上素质对工作输出的影响是10倍的，这一点我并不奇怪。综合来看，他们可以从可行模型的开始设计良好的实现，并且可能比替代方法简单好几倍。 有一种强调简单的方法，我喜欢称之为 \u0026quot;机会编程\u0026quot; 。基本上，在每个开发步骤中，都会选择要实现的功能集，以便以最小的工作量对程序的用户群体产生最大的影响。\n(全文完)\n","link":"https://huangbaihua.gitee.io/post/the-mythical-10x-programmer/","section":"post","tags":["系统架构","译文"],"title":"10倍程序员的秘密"},{"body":"不想当 CTO 的工程师不是合格的工程师，那么如何才能成为一名优秀的CTO? 本文从网络上精心挑选了一系列文章，对有志成为一名 CTO 的工程师提供一些经验和方法。\n源文: Awesome CTO (kuchin)\n优秀的首席技术官 目录 综合 招聘 管理 手册 研发流程 架构 技术 创业公司 相关内容 产品 市场营销 更多链接 综合 首席技术官的多角色 - Werner Vogels (Amazon CTO) 成为首席技术官必须是开发人员吗? (Quora) 寻找首席技术官的三大黄金法则 成为首席技术官 技术副总裁VS首席技术官 - Fred Wilson (Union Square Ventures) 创业公司中首席执行官和首席技术官之间成功的关系是什么? (Quora) #定义首席技术官 - Greg Brockman (Stripe CTO) 当发展到100名工程师时,首席技术官的角色演变 作为首席技术官或技术副总裁的第一个90天 成为首席技术官跟技术副总裁的不同之处 招聘 面试指南 - Joel Spolsky (StackOverflow co-founder) Joel测试： 改进代码的12个步骤 - Joel Spolsky 为什么程序员反而不会编程？ - Jeff Atwood (StackOverflow co-founder) 雇用最优秀的人 - Jeff Atwood 做好电话面试筛选 - Jeff Atwood Stripe工程面试流程 (Quora) 改进我们的工程面试流程 (Foursquare) Hitting the High Notes - Joel Spolsky 10大系统设计面试题 - (HackerNoon) 如何雇用世界级的工程师？ (angel.co) 招聘高级工程师很困难？可能是你的问题 反向面试 我不雇用你的11个真实原因 - Charity Majors 亚马逊是如何面试的 来自 Keith Rabois的教训: 如何面试高管？ 来自 Keith Rabois的教训: 如何吸引人才？ 反向面试题 管理 10倍程序员的秘密 - Salvatore Sanfilippo (author of Redis) 做工程师还是做项目经理? - Charity Majors 研发的日程表，管理者的日程表 - Paul Graham (Y Combinator) 谷歌的软件工程 Google re:Work 44节工程管理课程 (correct link to non-violent communication for lesson 34) 与员工谈薪酬的秘密 优秀的领导和管理 (Github) 从技术到领导力的进步 审查流程 - Cap Watkins 来自顶级科技公司的12名经理自述 可预测的交付 在大公司中，如何升到执行副总裁？ (Quora) 我应该成为一名管理者么? - Cap Watkins 刚成为项目经理时，是如何失败的？ 最多管理的设计模式 工程管理 (Github) 入职软件工程师 让你的团队负责任 管理者常见问题 绩效考核的力量 工程管理的原则 补偿最佳实践 Draw The Owl and Other Company Values You Didn’t Know You Should Have 经理的职责及权利 做了经理人，我还能快乐么? 优秀的规划流程的秘密 — 来自 Airbnb and Eventbrite 的教训 Increment: 团队 软件工程师的职业发展框架 黑客团队的沟通 如何组建创业公司的工程师团队 拥抱你的经理 来自 Keith Rabois的教训: 如何成为一名高效的执行者 上下文切换如何破坏您的生产力 手册 Atlassian 团队游戏手册 Valve 员工手册 Basecamp 员工手册 GitLab 团队手册 HashiCorp是如何运作的 研发流程 Scrum/敏捷开发 给经理和高管的Scrum介绍 用敏捷方法编写用户故事，实例和模板 持续集成 / 持续部署 持续集成的基本原则是什么? 产品经理的持续交付和DevOps指南 Git代码管理 Git工作流比较 一个成功的Git分支模型 替代方案: 基于主干的开发 (focused on DevOps and CI/CD) 计划 Evidence Based Scheduling - Joel Spolsky (StackOverflow co-founder) 为什么要停止担心并爱上技术债务 [书籍] 人月神话 危机 如何写事故报告 事故报告清单 (GitHub) 创业者的经验教训--五个为什么？ - Eric Ries (creator of the Lean Startup) 在半夜叫醒开发人员的最佳方法 用安全的方法在生产环境上测试 架构 十二要素 App 响应式宣言 分布式系统介绍 - Kyle Kingsbury (aphyr, author of Jepsen) 微服务--请不要这样做 (also: HackerNews discussion) 2018年微服务疯狂之殇 将微服务缩小为功能 微服务的设计模式 无服务器架构 (Quora) NoSQL数据库：调查与决策指南 设计实用性RESTful API的最佳实践 10个现代软件过度工程的错误 我如何编写测试 Lambda 架构 进化式数据库设计 (Martin Fowler) 正确进行数据库迁移 强大的可扩展性 亚马逊历史上最重要的一封内部邮件 建立你自己的X 金融科技与小数据工程的参考指南 技术 综合 用通俗易懂的语言解释大O表示法 Coding Interview University 机器学习 棒极了的机器学习 (GitHub) 日常机器学习的最佳资源 (Quora) 机器学习速成班：使用TensorFlow APIs (Google) 编码者的深度学习 分布式基础理论 什么是CAP定理 (Quora) 重新审视CAP定理 安全 SaaS CTO安全检查表 云计算 亚马逊网络服务开放指南 亚马逊网络服务 微软Azure 为AWS专家提供的谷歌云服务 Javascript SuperheroJS collection JS: The Right Way 前端开发手册2017版 创业公司 创业公司必须要做好哪些事情? (Quora) 我做CEO学到的85件事 创业公司CEO的第二份工作是什么? 如果我的孩子成为创业者，我会告诉他们的事 风投在做投资时到底看中的是什么? (Quora) 对于一个小型创业公司来说，CTO的股权会是多少? (Quora) 作为创业公司的员工，你怎么知道什么时候该辞职? (Quora) 来自风险投资的创业公司的融资演讲稿集合 YC的A轮尽职调查表 期权与现金 如何投资创业公司 - Sam Altman 种子资金筹集指南 创业者游戏手册 - Sam Altman Y Combinator 创业班 精益画布 + Miro template 开源的Figma 融资演讲稿模板 相关内容 Knowledge-Sharing Architects As An Alternative to Coding Architects 洽谈工作机会的十条规则 (also: HackerNews discussion) 经验丰富的程序员有哪些最佳实践? (Quora) 对程序员名称的误解 2016年欧洲软件开发薪资调查 (O'Reilly) DevOps：将开发和运营结合起来 (Atlassian) 数据运营 如何准备演讲 被低估的软件工程技能：良好的写作能力 金字塔原理 高级工程师的检查单 技术尽职调查表 产品 怎样才能成为优秀的产品经理 如果你认为你不需要产品副总裁...... 红海，如何寻找有利可图的创业点子 Product North Star Metric 前1%的产品经理和前10%的产品经理有什么区别? - (Quora) 如何聘请产品经理 创造性思维的秘密 StellarPeers - 产品管理专访 产品团队VS功能团队 大多数创业公司应该是猎鹿人 Shape Up: Stop Running in Circles and Ship Work that Matters 如何编写你的第一份战略路线图 市场营销 开发人员营销指南 创业公司营销和公关的顶级资源 SaaS电子邮件营销手册 更多链接 惊人的假象 (GitHub) 工程博客 (GitHub) Awesome Awesomeness (GitHub) Awesome.re (GitHub) Chief Technology Officer vs Coder Thinker Organizer (GitHub) 高级软件工程师 Socal CTO CTO资源列表 (GitHub) Awesome CTO 资源 (GitHub) 开发者的免费工具 版权 ","link":"https://huangbaihua.gitee.io/post/awesome-cto/","section":"post","tags":["技术管理","系统架构","译文"],"title":"优秀的首席技术官"},{"body":" 关于baihua.huang 网络信息 Email: huangbaihua@vip.qq.com GitHub: https://github.com/huangbaihua001 座右铭: 你只管努力,剩下的都交给天意。 个人简介 热爱软件行业，从未敢懈怠，为梦想努力着... 🚀🚀🚀🚀🚀🚀🚀 ","link":"https://huangbaihua.gitee.io/about/","section":"","tags":["关于"],"title":""},{"body":" baihua.huang 的个人技术博客免责声明 本站为个人技术博客门户，作为个人的网络空间，分享提供的所有内容仅供学习、分享与交流，我们不保证内容的正确性。通过使用本站内容随之而来的风险与本站无关。\n本站的原创内容均以知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议\n发布，若须转载本站文章请注明出处，谢谢。\n免责条款： 1、本站提醒访问者：请在转载、或者下载有关作品时务必保留原文链接，如果您发现有您未署名的作品，请立即和我们联系，我们会在第一时间加上您的署名或作相关处理。\n2、当本网站以链接形式推荐其他网站内容时，本网站并不对这些网站或资源的可用性负责，且不保证从这些网站获取的任何内容、产品、服务或其他材料的真实性、合法性，对于任何因使用或信赖从此类网站或资源上获取的内容、产品、服务或其他材料而造成（或声称造成）的任何直接或间接损失，本网站均不承担任何责任。\n3、除另有明确说明或者中国法律有强制性规定外，本网站用户原创的作品，本网站及作者共同享有版权，其他网站及传统媒体如需使用，须取得本网站的授权，未经授权严禁转载或用于其它商业用途。\n4、本网站所刊载的各类形式（包括但不仅限于文字、图片、图表）的作品仅供参考使用，并不代表本网站同意其说法或描述，仅为提供更多信息，也不构成任何投资建议。对于访问者根据本网站提供的信息所做出的一切行为，除非另有明确的书面承诺文件，否则本网站不承担任何形式的责任。\n5、访问者在确定使用本站时，即同意对本站提供您的部分信息为本站所用。访问者在本网站注册时提供的一些个人资料，本网站除您本人同意及第六条规定外不会将用户的任何资料以任何利益方式泄露给任何一方。\n6、当政府部门、司法机关等依照法定程序要求本网站披露个人资料时，本网站将根据执法单位之要求或为公共安全之目的提供个人资料。在此情况下之任何披露，本网站均得免责。\n7、若用户将个人密码告知他人或与他人共享注册账户，由此导致的任何个人资料泄露，本网站不负任何责任。\n8、本网站有部分内容来自互联网，如无意中侵犯了哪个媒体 、公司 、企业或个人等的知识产权，请来电或致函告之，本网站将在规定时间内给予删除等相关处理。\n网站运行： 1、本网站如因系统维护或升级而需暂停服务时，将事先公告。若因线路及非本站控制范围外的硬件故障或其它不可抗力而导致暂停服务， 于暂停服务期间造成的一切不便与损失， 本网站不负任何责任。\n2、任何由于黑客攻击、计算机病毒侵入或发作、因政府管制而造成的暂时性关闭等影响网络正常经营的不可抗力而造成的个人资料泄露、丢失、被盗用或被窜改等，本网站均得免责。\n法律责任： 1、凡以任何方式登陆本网站或直接、间接使用本网站资料者，视为自愿接受本网站声明的约束。\n2、本声明未涉及的问题参见国家有关法律法规，当本声明与国家 法律法规冲突时，以国家法律法规为准。\n以上声明内容的最终解释权归 baihua.huang 个人技术博客 huangbaihua.cn 所有 请联系邮箱:huangbaihua#viq.qq.com(将#换成@)，作者会及时进行处理","link":"https://huangbaihua.gitee.io/dsclaimer/","section":"","tags":["免责声明"],"title":""},{"body":"","link":"https://huangbaihua.gitee.io/tags/%E5%85%B3%E4%BA%8E/","section":"tags","tags":null,"title":"关于"},{"body":"","link":"https://huangbaihua.gitee.io/tags/%E5%85%8D%E8%B4%A3%E5%A3%B0%E6%98%8E/","section":"tags","tags":null,"title":"免责声明"},{"body":"","link":"https://huangbaihua.gitee.io/archives/","section":"","tags":null,"title":""},{"body":"","link":"https://huangbaihua.gitee.io/tags/index/","section":"tags","tags":null,"title":"index"},{"body":"","link":"https://huangbaihua.gitee.io/series/","section":"series","tags":null,"title":"Series"}]